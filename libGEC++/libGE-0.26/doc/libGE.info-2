This is doc/libGE.info, produced by makeinfo version 4.7 from
./doc/libGE.texi.

   This manual is for libGE, version 0.26, a C++ library that
implements the Grammatical Evolution mapping process.

   Copyright (C) 2003-2006 Biocomputing-Developmental Systems Centre,
University of Limerick, Ireland.  Permission is granted to copy,
distribute and/or modify this document under the terms of the GNU Free
Documentation License, Version 1.2 or any later versions published by
the Free Software Foundation; with no Invariant Sections, no
Front-Cover Texts, and no Back-Cover Texts. A copy of the license is
included in the section entitled "GNU Free Documentation License".


File: libGE.info,  Node: EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-libtcc.cpp,  Next: EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-lua.cpp,  Prev: EXAMPLES/IntertwinedSpirals/GE_MITGALIB/WrappedSLangPhenotype,  Up: Intertwined Spirals Implementation with GE_MITGALIB

7.3.6.10 `spiral-libtcc.cpp'
............................

The file `spiral-libtcc.cpp' contains the functions directly related to
the evaluation of each GALib individual using the libTCC library (part
of the TinyCC distribution). The intertwined spirals example uses the C
API of the libTCC library to interpret, execute, and evaluate the GE
phenotype. Evaluation of the phenotype in this way results in
significant improvements in execution time over language compilers e.g.
GCC, and TCC. The following section describes the various files and
functions that are part of the libTCC backend for the intertwined
spirals example.

   The function `app_init' function, called from the function `main' in
the file `main.cpp' is responsible for initialising the libGE mapper,
loading the BNF grammar file, and setting up the resources required to
evaluate the GE phenotypes using the libTCC evaluator in the function
`objfunc'.

   The `GEGrammarSI' `mapper' object, which is declared in the
`main.cpp', is initialised by specifying the maximum number of mapping
wraps `wrappingEvents' and the BNF `grammarFile' is loaded using the
`readBNFFile' member function. Both of these variables are supplied as
parameters to the`app_init' function. If the process of loading the
grammar fails, an error message is printed to the standard error stream
(`std::cerr') and the program exits.

   In order to minimise the time taken to extract, evaluate and award a
fitness to a GE phenotype, the start and end code that is placed before
and after a GE phenotype are loaded into character buffers in this
function. These buffers are accessed in the function `objfunc', every
time a GALib individual needs is evaluated. In this example, the C code
in the file `spiralstart.c' and `spiralend.c' are read into the `char'
arrays `SPstart' and `SPend' respectively. The last task in this
function is to load the file `GEspiral.c' into another character buffer
called `GEfunc'. This file contains the definitions of the functions
and variables that will be used either directly or indirectly by the GE
phenotype code. For more information about these files, *note
GEspiral.c:: and *Note spiralstart.c::, and *Note spiralend.c::.

   The `objfunc' function is responsible for evaluating an individual
(passed in the argument `g'). The `setGenotype()' method from the
mapper is used to create a `Genotype' structure within the mapper, from
the genome `g'. If the resulting phenotype is not valid, a fitness of
0.0 is returned and the program exits. If the phenotype is valid, then
the evaluation of the phenotype using the libTCC library proceeds.

   The first task is to set up a new libTCC state which can compile and
execute C code. This is achieved by calling the function `tcc_new'. The
function `tcc_set_output_type' is then called to specify that
compilation of the C code should take place in main memory to maximise
performance. The math library `m' is also added to the libTCC state
using the `tcc_add_library' function to allow the use of a number of
math functions at the evaluation stage.

   The next step is to make the various functions and variables that
are defined in the code stored in the buffer `GEfunc' available in the
libTCC state.  This is achieved by calling the function
`tcc_compile_string' and passing the current libTCC state and the
buffer containing the code. It is important to note that the code in
the buffer `GEfunc' is not executed at this stage.  The purpose of this
call is simply to compile the code and make it available to the
phenotype code which we will execute next.

   Before the phenotype can be executed in the libTCC state, it must be
wrapped with the start and end code stored in the buffers `SPstart' and
`SPend'. The `char' buffer `buffer' is used to store the result of
concatenating the buffer `SPstart', the phenotype code, and the buffer
`SPend'. An example of this concatenation is shown in *Note
WrappedCPhenotype::. This buffer is then passed to the libTCC state
using the `tcc_compile_string' function. If the compilation is
successful, the libTCC state contains the executable form of the
wrapped phenotype, the supporting functions, and the variables required
to evaluate the GE phenotype.

   In order to execute the code in memory, the `main' function
(declared in the file `spiralstart.c') must be explicitly invoked. This
function is accessed by first calling the function `tcc_relocate'. This
makes all function and variable symbols accessible through the C
interface and should be called after every call to
`tcc_compile_string'. The function `tcc_get_symbol' is then called with
a pointer to the libTCC state, a reference to a variable of type
`unsigned long', and the name of the symbol we require ("main"). If the
required symbol is found, the `tcc_get_symbol' function stores its
address in the `unsigned long' variable. This variable is then cast
into a function pointer of type `int (*p_tccMainFunc)()'. The main
function can the be invoked in the libTCC state by calling the function
through the pointer i.e. `p_tccMainFunc()'.

   One the main function has completed, the function `objfunc' must
invoke the function `AssignFitness' to retrieve the fitness value of
the GE individual. This is performed using the same method as the main
function invocation shown above. A function pointer which matches the
signature of the function `AssignFitness' must first be created. In
this example, the pointer is called `p_tccFitnessFunc"'. The libTCC
function `tcc_get_symbol' is then called to store the symbol location
of this function in the temporary variable `val'. This variable is then
cast and stored in the function pointer. The return value of the
`AssignFitness' function can then be retrieved by invoking the function
through the pointer in the normal fashion i.e. `fitness =
p_tccFitnessFunc();'. The function then deletes the libTCC state using
the function `tcc_delete'.

   The function then checks that the fitness value is a valid number.
If this test fails, the fitness value is set to 0.

   Before the function returns this value, it sets the effective size
of the genotype in the genome object. This value is used by the
effective crossover operator.

   Finally, the fitness is returned and the function exits.

   Finally, the `print_individual' function receives a genome as
argument, performs its mapping to a phenotype structure, and prints it
onto the screen, along with measurements of the genotype, generated
phenotype, and the mapping process itself.


File: libGE.info,  Node: EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-lua.cpp,  Next: EXAMPLES/IntertwinedSpirals/GE_MITGALIB/GEspiral.lua,  Prev: EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-libtcc.cpp,  Up: Intertwined Spirals Implementation with GE_MITGALIB

7.3.6.11 `spiral-lua.cpp'
.........................

The file `spiral-lua.cpp' contains the functions directly related to the
evaluation of each GALib individual using the Lua evaluator. The
intertwined spiral uses the C API of the Lua library to interpret,
execute, and evaluate the GE phenotype. Evaluation of the phenotype in
this way results in significant improvements in execution time over
language compilers e.g. GCC, and TCC. The following section describes
the various files and functions that are part of the Lua backend for
the intertwined spirals example.

   In order to access the Lua C API through the C++ code in
`spiral-lua.cpp', the `#include <header.h>' directives must be enclosed
in a special directive called `extern "C"' e.g.

extern "C"
{
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
}
 This tells the compiler that the code in these files is C code and not
C++ code.  The functions in the file `spiral-lua.cpp' make use of the GE
`GEGrammarSI' mapper, defined in the `main.cpp' file. A global pointer
to a `lua_State', called `L' in this example, is also created at the
top of the file.for use by all the functions in the file.

   The `app_init' function, called from the `main' function, is
responsible for initialising the libGE mapper and initialising the Lua
interpreter.

   The `GEGrammarSI' mapper object used in this function is declared in
the file `main.cpp'. The number of wrapping events and the path to the
grammar are supplied in parameters to this function. The `mapper'
object is initialised by specifying the maximum number of mapping wraps
and loading the BNF grammar file using the `readBNFFile' member
function. If the process of loading the grammar fails, an error message
is printed to the standard error stream (`std::cerr') and the program
exits.

   The Lua state is opened in this function by a call to the lua API
function `lua_open'. Additional math and io libraries are added to this
state using the function `luaL_openlibs'. Once completed, the Lua state
is then ready to interpret and execute Lua code.

   In order to minimise the time required for individual evaluations in
the function `objfunc', the Lua code in `GEspiral.lua' is loaded into
the state using the function `luaL_dofile'. This function loads and
executes the Lua code in this file which is discussed in more detail in
*Note EXAMPLES/IntertwinedSpirals/GE_MITGALIB/GEspiral.lua::. It is
important to note that, because the file only contains variable
declarations and function implementations, no code is executed at this
time. If an error occurs while loading this file, Lua sets a error
message at the top of its call stack. Each element on the Lua stack has
an index e.g. an index of `-1' represents the element at the top of the
stack. This index value is supplied to the`lua_tostring' to retrieve
the error message. The message is then printed to standard error output
and the program exits.

   The function `objfunc' provides the definition of the evaluation
operator required by GALib. This function takes one argument of type
`GAGenome' and returns a floating point value representing the fitness
awarded to that `GAGenome' object. In order to evaluate the genome, the
GAGenome object has to be cast into its derived type (`GEListGenome').
This allows the extra member functions specified in the class
`GEListGenome' to be used in this function.

   Once cast, the `GEListGenome' is then assigned to the `mapper'
object. A libGE `Phenotype' is then extracted from the same `mapper'
object. If the phenotype is invalid, a fitness value of 0.0 is returned
and the function exits. If the phenotype is valid, the full executable
code needs to be constructed so that the phenotype can be evaluated in
the Lua backend.

   Instead of writing the phenotype code to a new file, the code is
constructed in memory by appending the required start code, phenotype
code, and end code to a `string' object (The start and end code are
described in *Note
EXAMPLES/IntertwinedSpirals/GE_MITGALIB/LuaStartCode:: and *Note
EXAMPLES/IntertwinedSpirals/GE_MITGALIB/LuaEndCode::).

   This code is executed in the Lua runtime by calling the function
`luaL_dostring' and passing it a pointer to the Lua state and the buffer
containing the code to be executed. If execution fails, the error
message is retrieved from the Lua stack and printed to standard error
output and the program exits.

   If the compilation and execution is successful, the function
`lua_getglobal' is called to retrieve the Lua variable
`sumFitCaseTimes'. This function pushes the variable on to the top of
the stack. The value is checked and retrieved from the stack using the
functions `lua_isnumber' and `lua_tonumber'. The value is then assigned
to the `fitness' variable.

   Before returning the fitness value, the effective size of the GE
genotype is stored in the mapper object using the `setEffectiveSize'
member function of the `GEListGenome' class.

   Finally, the fitness is returned and the function exits.

   Finally, the `print_individual' function receives a genome as
argument, performs its mapping to a phenotype structure, and prints it
onto the screen, along with measurements of the genotype, generated
phenotype, and the mapping process itself.


File: libGE.info,  Node: EXAMPLES/IntertwinedSpirals/GE_MITGALIB/GEspiral.lua,  Next: EXAMPLES/IntertwinedSpirals/GE_MITGALIB/LuaStartCode,  Prev: EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-lua.cpp,  Up: Intertwined Spirals Implementation with GE_MITGALIB

7.3.6.12 `GEspiral.lua'
.......................

The file `GEspiral.lua' defines the variables and functions required to
evaluate the GE phenotype for the intertwined spirals problem using the
Lua runtime. It provides the functions `initVals' and `AssignFitness'
and the grammar functions `if_cond', `pdiv', `myadd', `mysub', `mymul'
and `myadd'. The functionality of the code is the same as that found in
the file `GEspiral.c' and descriptions of the variables and functions
can be found in *Note GEspiral.c::.


File: libGE.info,  Node: EXAMPLES/IntertwinedSpirals/GE_MITGALIB/LuaStartCode,  Next: EXAMPLES/IntertwinedSpirals/GE_MITGALIB/LuaEndCode,  Prev: EXAMPLES/IntertwinedSpirals/GE_MITGALIB/GEspiral.lua,  Up: Intertwined Spirals Implementation with GE_MITGALIB

7.3.6.13 Lua start code
.......................

In order to execute the phenotype in the Lua state, code must be
prepended and appended to the phenotype. The following code segment
shows the code that is prepended to the phenotype. It starts with a
call to `initVals' defined in `GEspiral.lua' and then sets up some
temporary variables. It also sets up a for loop to iterate over each
test case. In the body of this loop, the current test case coordinates
are retrieved and an assignment statement is started. This statement is
left open to allow the addition of the GE phenotype code. The code that
is appended to the phenotype code in order to construct a valid Lua
program is described in the next section.



initVals();
temp = 0.0;
fit = 0.0;
for i=0,193,1 do ";
    x=xvals[i];
    y=yvals[i];
    temp=


File: libGE.info,  Node: EXAMPLES/IntertwinedSpirals/GE_MITGALIB/LuaEndCode,  Next: EXAMPLES/IntertwinedSpirals/GE_MITGALIB/WrappedLuaPhenotype,  Prev: EXAMPLES/IntertwinedSpirals/GE_MITGALIB/LuaStartCode,  Up: Intertwined Spirals Implementation with GE_MITGALIB

7.3.6.14 Lua end code
.....................

The following code is appended to the phenotype to complete the
assignment statement started in the start code and to evaluate the
class which should be assigned to the current test case. If the value
of the phenotype (stored in `temp' is less than 0, then the class of
the test case is 0. If the phenotype evaluated to 0 or greater, then
the class of the test case is 1. The class is stored in the array
`Evolved' (declared in  `GEspiral.lua').


   ;

   if temp < 0 then
        Evolved[i]=0;
   else
        Evolved[i]=1;
   end
end
Fitness_Variable = AssignFitness();


File: libGE.info,  Node: EXAMPLES/IntertwinedSpirals/GE_MITGALIB/WrappedLuaPhenotype,  Next: EXAMPLES/IntertwinedSpirals/GE_MITGALIB/Makefile,  Prev: EXAMPLES/IntertwinedSpirals/GE_MITGALIB/LuaEndCode,  Up: Intertwined Spirals Implementation with GE_MITGALIB

7.3.6.15 Example wrapped Lua phenotype
......................................

A phenotype complete with start and end code is shown below as an
example.


initVals();
temp = 0.0;
fit = 0.0;
for i=0,193,1 do ";
    x=xvals[i];
    y=yvals[i];
    temp=x + y;

   if temp < 0 then
        Evolved[i]=0;
   else
        Evolved[i]=1;
   end
end
Fitness_Variable = AssignFitness();


File: libGE.info,  Node: EXAMPLES/IntertwinedSpirals/GE_MITGALIB/Makefile,  Prev: EXAMPLES/IntertwinedSpirals/GE_MITGALIB/WrappedLuaPhenotype,  Up: Intertwined Spirals Implementation with GE_MITGALIB

7.3.6.16 `Makefile'
...................

The `Makefile' contained in the example allows you to create a program
using a choice of evaluators for your phenotype strings. Use `make' to
create all executables, or `make GE*' to create a specific evaluator
implementation (where `*' is any of `GCC', `SLANG', `TCC', `LIBTCC', or
`LUA'). At the top of the file there are definitions for the location
of the GALib, GE, and evaluator specific header and library files. If
you have installed any of these in non-standard locations, make sure
the values are adjusted to suit your system.

   Note: Some of the evaluators require the pre-compilation of the
`GEspiral.c'. This is automatically done by the `Makefile' when the
relevant evaluators are chosen.


File: libGE.info,  Node: Intertwined Spirals Implementation with GE_EO,  Next: Intertwined Spirals Performance,  Prev: Intertwined Spirals Implementation with GE_MITGALIB,  Up: Intertwined Spirals Problem

7.3.7 GE_EO
-----------

* Menu:

* Intertwined Spirals EO Example User Guide::
* EXAMPLES/IntertwinedSpirals/GE_EO/GEEA.cpp::
* EXAMPLES/IntertwinedSpirals/GE_EO/eoGE.h::
* EXAMPLES/IntertwinedSpirals/GE_EO/eoGEInit.h::
* EXAMPLES/IntertwinedSpirals/GE_EO/eoGEMutation.h::
* EXAMPLES/IntertwinedSpirals/GE_EO/eoGEQuadCrossover.h::
* EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-gcc_tcc.h::
* EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-slang.h::
* EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-libtcc.h::
* EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-lua.h::
* EXAMPLES/IntertwinedSpirals/GE_EO/Makefile::

   The example using the Evolutionary Objects (EO) library can be found
in `EXAMPLES/IntertwinedSpirals/GE_EO'. The following sections contain a
user's guide and a description of the files in this example.


File: libGE.info,  Node: Intertwined Spirals EO Example User Guide,  Next: EXAMPLES/IntertwinedSpirals/GE_EO/GEEA.cpp,  Prev: Intertwined Spirals Implementation with GE_EO,  Up: Intertwined Spirals Implementation with GE_EO

7.3.7.1 EO Example User Guide
.............................

The EO library has a powerful command-line parser, which is
fully-configurable. This example uses that parser to specify both the
standard GA parameters, and also the GE specific parameters.

   Parameters are passed to the executable in the following fashion:

   `./executable -param_short_name[=value]'

   or

   `./executable --param_long_name[=value]'

   The following are the parameters accepted by this example, and their
default values:

   * -h, -help: prints help message (default is 0);

   * -stopOnUnknownParam: stop if unknown parameter entered (default is
     1);

   * -C, -pCross: probability of crossover (default is 0.9);

   * -E, -effCross: use effective crossover (default is 0);

   * -M, -pMut: probability of mutation (default is 1);

   * -b, -pMutPerBit: probability of bit-flip mutation (default is
     0.01);

   * -s, -sensibleInit: use sensible initialisation (default is 0);

   * -x, -minSize: minimum size for random initialisation (default is
     15);

   * -X, -maxSize: maximum size for random initialisation (default is
     25);

   * -r, -grow: grow ratio for SI (default is 0.5);

   * -d, -maxDepth: maximum depth for SI (default is 10);

   * -T, -tailSize: tail size for SI (default is 0);

   * -t, -tailRatio: tail ratio for SI (default is 0);

   * -g, -grammarFile: grammar file (default is "grammar.bnf");

   * -w, -wrappingEvents: number of wrapping events (default is 0);

   * -L, -Load: save file to restart run (no default);

   * -S, -Status: status file (default is
     "./<name_of_executable>.status");

   * -R, -seed: random number seed (default is random);

   * -P, -popSize: population size (default is 100);

   * -G, -maxGen: maximum number of generations (default is 10).

   For example, to run the `GELUA' implementation, using the grammar
file "grammar.bnf", with a population size of 500 individuals, for 50
generations, using random seed 1, and leaving all other parameters to
standard values, the command to execute is:

   `GELUA -g=grammar.bnf -P=500 -G=50 -R=1'


File: libGE.info,  Node: EXAMPLES/IntertwinedSpirals/GE_EO/GEEA.cpp,  Next: EXAMPLES/IntertwinedSpirals/GE_EO/eoGE.h,  Prev: Intertwined Spirals EO Example User Guide,  Up: Intertwined Spirals Implementation with GE_EO

7.3.7.2 `GEEA.cpp'
..................

The file `GEEA.cpp' contains the `main()' function, and is the central
point of control over the evolutionary process. It begins by including
all required EO include files, followed by a declaration of the fitness
type to be used, and the type of each individual. The typedef directive
declares the type `Indi' as a substitute name for the individual type
`eoGE<MyFitT>'. The class eoGE is declared in the file `eoGE.h' and is
discussed in the next section. This example uses a custom genotype
structure because EO does not have direct support for variable-length
integer-based structures. The file `GEEA.cpp' also declares the libGE
`GEGrammarSI' mapper.

   The function `main_function()' starts by defining all parameters
available to the system using an instance of the `eoParser' class. The
name of the parameter, the associated help messages, and the default
value are supplied to the `eoParser::createParam' member function.

   The fitness operator is then declared by creating an instance of the
template class `eoGEEvalFunc'. The template in this case concerns the
type of individual to be evaluated (called `Indi' in this example). The
operator object is supplied with the libGE mapper object and the path
of the BNF grammar file to use.

   A number of fitness operator classes are provided in the intertwined
spirals example for EO which use a differend backend platform to
evaluate the GE phenotype. Each of the evaluation backends are
implemented in files named `eoGEEvalFunc-*.cpp' with `*' replaced by
the name of the backend e.g. `eoGEEvalFunc-slang.cpp'. All the fitness
operator classes are called `eoGEEvalFunc' and each implements the
interface required by EO i.e. they implement an operator function `()'
which takes an eo individual, evaluates it, and then assigns a fitness
value. The particular backend fitness operator class created at
execution time is determined during compilation. It is therefore
sufficient at this point to create an instance of the class using the
name `eoGEEvalFunc'. The compilation process is described in more
detail later in this section.

   The function `main_function' then declares an objective function call
counter and a `eoPOP' object to store the population of `Indi'
individuals.

   The random seed generator and the `Indi' population are then
registered with a new instance of the class `eoState'. This class is
responsible for initialising and evaluating the population in the case
of a new run, or loading the population from disk if continuing a
previous run.

   The definition of roulette-wheel selection and steady-state
replacement (GE style) follow, along with the definition of the genetic
operators to use (which are encapsulated into a `eoTransform' object).
Finally, a series of continuators, checkpoints, statistics objects and
monitors are defined and associated together. For more information on
these settings, see the EO documentation.

   At the end of the function `main_function', the actual evolutionary
algorithm object is declared. This `eoEasyEA' instance is associated
with the defined checkpoints, evaluation function, selection procedure,
genetic operators, and replacement mechanism. The evolutionary cycle
consists merely of associating the EA object with the current
population object `pop'.

   The function `main', declared at the bottom of the file `GEEA.cpp'
consists of a protected call to the function `main_function' in a
try/catch block to handle any execution exceptions.


File: libGE.info,  Node: EXAMPLES/IntertwinedSpirals/GE_EO/eoGE.h,  Next: EXAMPLES/IntertwinedSpirals/GE_EO/eoGEInit.h,  Prev: EXAMPLES/IntertwinedSpirals/GE_EO/GEEA.cpp,  Up: Intertwined Spirals Implementation with GE_EO

7.3.7.3 `eoGE.h'
................

The file `eoGE.h' defines the class `eoGE', which represents a genome.
The `eoGE' genome consists of a vector of `unsigned char' elements.
This type was chosen because it is typically represented by 8 bits,
which is the standard size of GE codons.

   The methods `printOn()' and `readFrom()' output or read a genome
using a standard input or output stream respectively. The method
`getEffectiveSize()' merely returns the recorded effective size of the
genotype of this individual.


File: libGE.info,  Node: EXAMPLES/IntertwinedSpirals/GE_EO/eoGEInit.h,  Next: EXAMPLES/IntertwinedSpirals/GE_EO/eoGEMutation.h,  Prev: EXAMPLES/IntertwinedSpirals/GE_EO/eoGE.h,  Up: Intertwined Spirals Implementation with GE_EO

7.3.7.4 `eoGEInit.h'
....................

The file `eoGEInit.h' defines the class `eoGEInit' which contains
member functions for population initialisation. The constructor of the
class reads, processes, and stores the related EO parameters to select
a random or a sensible method for population initialisation.

   In the case of a random initialisation, the method `operator()' calls
the method `randomInit()'. This method creates individuals between the
sizes `minSize' and `maxSize' containing random `unsigned char' numbers.

   If sensible initialisation is selected, the mapper's `init()' method
is called, and if successful, the contents of its `Genotype' structure
are used to initialise the `_genotype' object passed as an argument.


File: libGE.info,  Node: EXAMPLES/IntertwinedSpirals/GE_EO/eoGEMutation.h,  Next: EXAMPLES/IntertwinedSpirals/GE_EO/eoGEQuadCrossover.h,  Prev: EXAMPLES/IntertwinedSpirals/GE_EO/eoGEInit.h,  Up: Intertwined Spirals Implementation with GE_EO

7.3.7.5 `eoGEMutation.h'
........................

The file `eoGEMutation.h' declares the class `eoGEMutation', which
implements a point mutation operator, as used in standard GE. The
mutation is applied to genotypes as arguments to the `operator()'
method (the probability of mutation is supplied in an argument to the
constructor).


File: libGE.info,  Node: EXAMPLES/IntertwinedSpirals/GE_EO/eoGEQuadCrossover.h,  Next: EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-gcc_tcc.h,  Prev: EXAMPLES/IntertwinedSpirals/GE_EO/eoGEMutation.h,  Up: Intertwined Spirals Implementation with GE_EO

7.3.7.6 `eoGEQuadCrossover.h'
.............................

The file `eoGEQuadCrossover.h' declares the class `eoGEQuadCrossover',
which implements the crossover operator to use during the evolutionary
cycle. Its constructor receives a boolean argument stating whether to
use a standard 1-point crossover or an effective crossover method.

   If standard 1-point crossover is specified, a random cut point is
selected within each individual. If effective crossover is selected,
each cut point must lie within the effective part of each individual
(that is, the part of its genome which has been read to create a
phenotype). After choosing the cut points, the second half of each
individual is then swapped.


File: libGE.info,  Node: EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-gcc_tcc.h,  Next: EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-slang.h,  Prev: EXAMPLES/IntertwinedSpirals/GE_EO/eoGEQuadCrossover.h,  Up: Intertwined Spirals Implementation with GE_EO

7.3.7.7 `eoGEEvalFunc-gcc_tcc.h'
................................

The file `eoGEEvalFunc-gcc_tcc.cpp' contains the functions directly
related to the evaluation of each EO individual using a C compiler such
as GCC.  The following section describes the various files and
functions that are part of the GCC backend for the intertwined spirals
example. This section also describes how GCC can be exchanged for
another C compiler called TCC (from the TinyCC distribution).

   The class `eoGEEvalFunc' is a template class which allows the
individual type `EOT' to be specified when an instance of the class is
created. The constructor is responsible for initialising the GE mapper
and setting up the C evaluator backend. The `mapper' object is
initialised by specifying the maximum number of mapping wraps and
loading the BNF grammar file using the `readBNFFile' member function.
Each of these values are supplied as parameters to the constructor
function. If the process of loading the grammar fails, an error message
is printed to the standard error stream (`std::cerr') and the program
exits.

   The next task in this function is to load the code that will be
placed before and after the phenotype which is contained in the files
`spiralstart.c' and `spiralend.c'. The function loads the contents of
these files into the `SPstart' and `SPend' buffers (character arrays).
These buffers are then used in the `objfunc' function for every
individual that is evaluated using the C compiler backend. For more
information about these files, *Note spiralstart.c::, and *Note
spiralend.c::.

   The member `operator()' provides the definition of the operator
required by EO for individual evaluation. It takes one argument of type
`EOT' which represents an EO individual. The function first checks that
this individual has not been evaluated previously by calling the member
function `EOT::invalid'. If the individual is invalid, then it needs to
be evaluated and assigned a fitness.  If the individual is valid, the
function exits.

   In order to evaluate this individual, the mapper must be supplied
with a valid libGE structure. This is constructed by generating an
array of integers and copying each element from the EO individual. This
array is then supplied to the constructor of the `Genotype' object.
This is then assigned to the `mapper' object using the member function
`setGenotype'. Once this is complete, a libGE `Phenotype' is extracted
from the `mapper' object.  If the phenotype is invalid, a fitness value
of 0.0 is returned and the function exits. If the phenotype is valid,
the full executable code needs to be constructed so that the phenotype
can be evaluated in the C backend.

   The first step in this process is to create a new empty file called
`individual.c'. The contents of the buffer `SPstart' are written out to
this file, followed by the contents of the phenotype, followed by the
contents of the buffer `SPend'. The file `individual.c' is then closed.
An example `individual.c' file is shown in *Note WrappedCPhenotype::.

   At this point, the file contains a full valid C program which should
be compilable by any C compiler. In this example, two different C
compilers can be used: GCC and TinyCC. If the macro
`GESPIRAL_USE_TCC_COMP' was defined when the file `spiral-gcc.cpp' was
compiled, then the TinyCC C compiler (called `tcc') is used. If the
macro was not defined, the GNU C compiler (called `gcc') is used. The
compiler program is called by invoking a `system' call with the name of
the compiler program and the name of the file containing the phenotype
and wrapper code i.e. `individual.c'. The phenotype file is also linked
with the object file produced by the compilation of the file
`GEspiral.c'. The `system' call also invokes the execution of the
compiled program and redirects all standard output to a file called
`result'. If the program compiles and the program runs successfully,
the file `result' should contain the number of fitness cases which were
classified correctly.

   To extact this value, the result file is opened and the first
integer value found is assigned to the variable `fitness'. The result
file is then closed.

   A number of tests are done on the fitness variable to ensure that it
is a number. Finally, the fitness is assigned to the EO individual
using the member function `EOT::fitness'. The function then exits.


File: libGE.info,  Node: EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-slang.h,  Next: EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-libtcc.h,  Prev: EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-gcc_tcc.h,  Up: Intertwined Spirals Implementation with GE_EO

7.3.7.8 `eoGEEvalFunc-slang.h'
..............................

The file `eoGEEvalFunc-slang.h' declares the class `eoGEEvalFunc'
required by EO for individual evaluation. This implementation uses the
S-Lang library.

   The class `eoGEEvalFunc' is a template class which allows the
individual type `EOT' to be specified when an instance of the class is
created. The constructor is responsible for initialising the GE mapper
and setting up the GCC or TCC evaluator backend. The `mapper' object is
initialised by specifying the maximum number of mapping wraps and
loading the BNF grammar file using the `readBNFFile' member function.
Each of these values are supplied as parameters to the constructor
function. If the process of loading the grammar fails, an error message
is printed to the standard error stream (`std::cerr') and the program
exits.

   The function initialises the S-Lang environment by calling the
S-Lang function `SLang_init_slang' and loads the stdio and math runtime
libraries by calling `SLang_init_stdio' and `SLang_init_slmath'. If any
of these functions fail, the program exits.

   Once the S-Lang environment is set up, the file `GEspiral.sl' (*note
EXAMPLES/IntertwinedSpirals/GE_MITGALIB/GEspiral.sl::) is loaded using
the function `SLang_load_file'. This file contains the functions and
variables required to evaluate a GE phenotype and is only required to
be loaded once.

   The member `operator()' provides the definition of the operator
required by EO for individual evaluation. It takes one argument of type
`EOT' which represents an EO individual. The function first checks that
this individual has not been evaluated previously by calling the member
function `EOT::invalid'. If the individual is invalid, then it needs to
be evaluated and assigned a fitness. If the individual is valid, the
function exits.

   In order to evaluate this individual, the mapper must be supplied
with a valid libGE structure. This is constructed by generating an
array of integers and copying each element from the EO individual. This
array is then supplied to the constructor of the `Genotype' object.
This is then assigned to the `mapper' object using the member function
`setGenotype'. Once this is complete, a libGE `Phenotype' is extracted
from the `mapper' object.  If the phenotype is invalid, a fitness value
of 0.0 is returned and the function exits. If the phenotype is valid,
the full executable code needs to be constructed so that the phenotype
can be evaluated in the S-Lang backend.

   Instead of having to construct the program and write it to a file to
be compiled, S-Lang allows the interpretation and execution of the
program in memory. This is achieved in this function by creating a
string called `buffer' and appending the start, phenotype, and end code
to it. Once the complete program is constructed, the `buffer' string
should contain a program that can execute within the S-Lang runtime.

   In order to extract information from the S-Lang runtime environment,
a new C++ variable is added to the environment using the
`SLadd_intrinsic_variable' function. This function requires the name of
the variable within the S-Lang environment (called `Fitness_Variable'
in this example), the address of the variable in the C/C++ runtime
(called `fitness' in this example), and the type of data stored in the
variable (`SLANG_INT_TYPE'). If any of the S-Lang functions function
fail, the program exits.

   The contents of the string are executed in the runtime by calling
the function `SLang_load_string'. Once execution has completed, the
value in the variable `fitness' should contain the number of fitness
cases which were correctly classified.

   A number of tests are done on the fitness variable to ensure that it
is a number. Finally, the fitness is assigned to the EO individual
using the member function `EOT::fitness'. The function then exits.


File: libGE.info,  Node: EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-libtcc.h,  Next: EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-lua.h,  Prev: EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-slang.h,  Up: Intertwined Spirals Implementation with GE_EO

7.3.7.9 `eoGEEvalFunc-libtcc.h'
...............................

The file `eoGEEvalFunc-slang.h' declares the class `eoGEEvalFunc'
required by EO for individual evaluation. This implementation uses the
libTCC library provided in the TinyCC distribution.

   The class `eoGEEvalFunc' is a template class which allows the
individual type `EOT' to be specified when an instance of the class is
created. The constructor is responsible for initialising the GE mapper
and setting up the libTCC evaluator backend. The `mapper' object is
initialised by specifying the maximum number of mapping wraps and
loading the BNF grammar file using the `readBNFFile' member function.
Each of these values are supplied as parameters to the constructor
function. If the process of loading the grammar fails, an error message
is printed to the standard error stream (`std::cerr') and the program
exits.

   In order to minimise the time taken to extract, evaluate and award a
fitness to a GE phenotype, the start and end code that is placed before
and after a GE phenotype are loaded into character buffers in this
function. These buffers are accessed in the function `objfunc' because
they are required for every GALib individual. In this example, the C
code in the file `spiralstart.c' and `spiralend.c' are read into the
`char' arrays `SPstart' and `SPend' respectively. The last task in this
function is to load the file `GEspiral.c' into another character buffer
called `GEfunc'. This file contains the definitions of the functions
and variables used either directly or indirectly by the GE phenotype
code. For more information about these files, *note GEspiral.c:: and
*Note spiralstart.c::, and *Note spiralend.c::.

   The member `operator()' provides the definition of the operator
required by EO for individual evaluation. It takes one argument of type
`EOT' which represents an EO individual. The function first checks that
this individual has not been evaluated previously by calling the member
function `EOT::invalid'. If the individual is invalid, then it needs to
be evaluated and assigned a fitness. If the individual is valid, the
function exits.

   In order to evaluate this individual, the mapper must be supplied
with a valid libGE structure. This is constructed by generating an
array of integers and copying each element from the EO individual. This
array is then supplied to the constructor of the `Genotype' object.
This is then assigned to the `mapper' object using the member function
`setGenotype'. Once this is complete, a libGE `Phenotype' is extracted
from the `mapper' object.  If the phenotype is invalid, a fitness value
of 0.0 is returned and the function exits. If the phenotype is valid,
the full executable code needs to be constructed so that the phenotype
can be evaluated in the libTCC backend.

   The first task is to set up a new libTCC state which can compile and
execute C code. This is achieved by calling the function `tcc_new'. The
function `tcc_set_output_type' is then called to specify that
compilation of the C code should take place in main memory to maximise
performance. The math library `m' is also added to the libTCC state
using the `tcc_add_library' function to allow the use of a number of
math functions at the evaluation stage.

   The next step is to make the various functions and variables that
are defined in the code stored in the buffer `GEfunc' available in the
libTCC state.  This is achieved by calling the function
`tcc_compile_string', and supplying the current libTCC state and the
buffer containing the code as arguments. It is important to note that
the code in the `GEfunc' buffer is not executed at this stage. The
purpose of this call is simply to compile the code and make it
available to the phenotype code which will be compiled next.

   Before the phenotype can be executed in the libTCC state, it must be
wrapped with the start and end code stored in the `SPstart' and `SPend'
buffers. The `char' buffer `buffer' is used to store the result of
concatenating the buffer `SPstart', the phenotype code, and the buffer
`SPend'. An example of this concatenation is shown in *Note
WrappedCPhenotype::. This buffer is then passed to the libTCC state
using the function `tcc_compile_string'. If the compilation is
successful, the libTCC state contains the executable form of the
wrapped phenotype, the supporting functions, and the variables required
to evaluate the GE phenotype.

   In order to execute the code in memory, the `main' function
(declared in the file `spiralstart.c') must be explicitly invoked. This
function is accessed by first calling the function `tcc_relocate'. This
makes all function and variable symbols accessible through the C
interface and should be called after every call to
`tcc_compile_string'. The function `tcc_get_symbol' is then called with
a pointer to the libTCC state, a reference to a variable of type
`unsigned long', and the name of the symbol we require ("main"). If the
required symbol is found, the `tcc_get_symbol' function stores its
address in the `unsigned long' variable. This variable is then cast
into a function pointer of type `int (*p_tccMainFunc)()'. The main
function can the be invoked in the libTCC state by calling the function
through the pointer i.e. `p_tccMainFunc()'.

   One the main function has completed, the function `objfunc' must
invoke the function `AssignFitness' to retrieve the fitness value of
the GE individual. This is performed using the same method as the main
function invocation shown above. A function pointer which matches the
signature of the function `AssignFitness' must first be created. In
this example, the pointer is called `p_tccFitnessFunc"'. The libTCC
function `tcc_get_symbol' is then called to store the symbol location
of this function in the temporary variable `val'. This variable is then
cast and stored in the function pointer. The return value of the
`AssignFitness' function can then be retrieved by invoking the function
through the pointer in the normal fashion i.e. `fitness =
p_tccFitnessFunc();'. The function then deletes the libTCC state using
the function `tcc_delete'.

   A number of tests are done on the fitness variable to ensure that it
is a number. Finally, the fitness is assigned to the EO individual
using the member function `EOT::fitness'. The function then exits.


File: libGE.info,  Node: EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-lua.h,  Next: EXAMPLES/IntertwinedSpirals/GE_EO/Makefile,  Prev: EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-libtcc.h,  Up: Intertwined Spirals Implementation with GE_EO

7.3.7.10 `eoGEEvalFunc-lua.h'
.............................

The file `eoGEEvalFunc-lua.h' declares the class `eoGEEvalFunc'
required by EO for individual evaluation. The intertwined spirals
example uses the C API of the Lua library to interpret, execute, and
evaluate the GE phenotype. Evaluation of the phenotype in this way
results in significant improvements in execution time over language
compilers e.g. GCC, and TCC. The following section describes the
various files and functions that are part of the Lua backend for the
intertwined spirals example.

   In order to access the Lua C API through the C++ code in the file
`eoGEEvalFunc-lua.h', the `#include <header.h>' directives must be
enclosed in a special directive called `extern "C"' e.g.

extern "C"
{
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
}

   This tells the compiler that the code in these files is C code and
not C++ code. A global pointer to a `lua_State', called `L' in this
example, is also created at the top of the file.for use by all the
functions in the file.

   This class is a template class which allows the individual type
`EOT' to be specified when an instance of the class is created. The
constructor is responsible for initialising the GE mapper and setting
up the libTCC evaluator backend. The `mapper' object is initialised by
specifying the maximum number of mapping wraps and loading the BNF
grammar file using the `readBNFFile' member function. Each of these
values are supplied as parameters to the constructor function. If the
process of loading the grammar fails, an error message is printed to
the standard error stream (`std::cerr') and the program exits.

   The Lua state is opened in this function by a call to the lua API
function `lua_open'. Additional math and io libraries are added to this
state using the function `luaL_openlibs'. Once completed, the Lua state
is then ready to interpret and execute Lua code.

   In order to minimise the time required for individual evaluations in
the function `objfunc', the Lua code in `GEspiral.lua' is loaded into
the state using the function `luaL_dofile'. This function loads and
executes the Lua code in this file which is discussed in more detail in
*Note EXAMPLES/IntertwinedSpirals/GE_MITGALIB/GEspiral.lua::. It is
important to note that, because the file only contains variable
declarations and function implementations, no code is executed at this
time. If an error occurs while loading this file, Lua sets a error
message at the top of its call stack. Each element on the Lua stack has
an index e.g. an index of `-1' represents the element at the top of the
stack. This index value is supplied to the`lua_tostring' to retrieve
the error message. The message is then printed to standard error output
and the program exits.

   The member `operator()' provides the definition of the operator
required by EO for individual evaluation. It takes one argument of type
`EOT' which represents an EO individual. The function first checks that
this individual has not been evaluated previously by calling the member
function `EOT::invalid'. If the individual is invalid, then it needs to
be evaluated and assigned a fitness.  If the individual is valid, the
function exits.

   In order to evaluate this individual, the mapper must be supplied
with a valid libGE structure. This is constructed by generating an
array of integers and copying each element from the EO individual. This
array is then supplied to the constructor of the `Genotype' object.
This is then assigned to the `mapper' object using the member function
`setGenotype'. Once this is complete, a libGE `Phenotype' is extracted
from the `mapper' object.  If the phenotype is invalid, a fitness value
of 0.0 is returned and the function exits. If the phenotype is valid,
the full executable code needs to be constructed so that the phenotype
can be evaluated in the Lua backend.

   Instead of writing the phenotype code to a new file, the code is
constructed in memory by appending the required start code, phenotype
code, and end code to a `string' object (The start and end code are
described in *Note
EXAMPLES/IntertwinedSpirals/GE_MITGALIB/LuaStartCode:: and *Note
EXAMPLES/IntertwinedSpirals/GE_MITGALIB/LuaEndCode::).

   This code is executed in the Lua runtime by calling the function
`luaL_dostring' and passing it a pointer to the Lua state and the buffer
containing the code to be executed. If execution fails, the error
message is retrieved from the Lua stack and printed to standard error
output and the program then exits.

   If the compilation and execution is successful, the function
`lua_getglobal' is called to retrieve the Lua variable
`sumFitCaseTimes'. This function pushes the variable on to the top of
the stack. The value is checked and retrieved from the stack using the
functions `lua_isnumber' and `lua_tonumber'. The value is then assigned
to the `fitness' variable.

   A number of tests are done on the fitness variable to ensure that it
is a number. Finally, the fitness is assigned to the EO individual
using the member function `EOT::fitness'. The function then exits.


File: libGE.info,  Node: EXAMPLES/IntertwinedSpirals/GE_EO/Makefile,  Prev: EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-lua.h,  Up: Intertwined Spirals Implementation with GE_EO

7.3.7.11 `Makefile'
...................

The file `Makefile' contained in the example allows you to create a
program using a choice of evaluators for your phenotype strings. Use
`make' to create all executables, or `make GE*' to create a specific
evaluator implementation (where `*' is any of `GCC', `SLANG', `TCC',
`LIBTCC', or `LUA'). At the top of the file there are definitions for
the location of the GALib, GE, and evaluator specific header and
library files. If you have installed any of these in non-standard
locations, make sure the values are adjusted to suit your system.

   The file `Makefile' uses the `-include' compiler flag to use only
the relevant include file for your choice of evaluator; if your
compiler does not accept that flag, you should replace it with the
appropriate flag.

   Finally, some of the evaluators require the pre-compilation of the
file `GEspiral.c'; this is done by the `Makefile', when the relevant
target implementations are chosen.


File: libGE.info,  Node: Intertwined Spirals Performance,  Prev: Intertwined Spirals Implementation with GE_EO,  Up: Intertwined Spirals Problem

7.3.8 Intertwined Spirals Performance
-------------------------------------

* Menu:

* GALib performance on Intertwined Spirals::
* EO performance on Intertwined Spirals::

   This section looks at the performance obtained with most of the
search engines tested, for this specific problem. All search engines
used a similar experimental setup: steady-state replacement, population
size of 500 individuals, 100 generations, probability of crossover of
0.9, and probability of bit-wise mutation of 0.01. Furthermore, each
experiment was performed with four different setups:

   * Using a standard GE approach;

   * Using effective crossover;

   * Using sensible initialisation;

   * Using a combination of the last two.

   The results show that the standard GE configuration fairs slightly
worse than the others and that the use of sensible initialisation alone
produces slightly better final individuals than others. The best
individual evolved over 30 runs achieved correct classification of
approximately 141 individuals.

   The average execution times of these runs for each of the five
backends and for both search engines are shown below.

   * GCC: 66m41.456s(GALib) 62m54.525s (EO)

   * TCC: 12m56.476s (GALib) 12m13.464s (EO)

   * LIBTCC: 98m20.012s (GALib) 8m49.939s (EO)

   * SLANG: 1m25.292s (GALib) 1m8.705s (EO)

   * LUA: 0m46.493s (GALib) 0m38.655s (EO)

   For reference, these results were obtained on a PC with a Pentium IV
processor running at 2.6GHz, 2048MB of memory, using Linux.


File: libGE.info,  Node: GALib performance on Intertwined Spirals,  Next: EO performance on Intertwined Spirals,  Up: Intertwined Spirals Performance

7.3.8.1 GALib performance
.........................

[text version of image not available]


File: libGE.info,  Node: EO performance on Intertwined Spirals,  Prev: GALib performance on Intertwined Spirals,  Up: Intertwined Spirals Performance

7.3.8.2 EO performance
......................

[text version of image not available]


File: libGE.info,  Node: FAQ,  Next: Copying This Manual,  Prev: Examples,  Up: Top

Appendix A Frequently Asked Questions
*************************************

   Q: When trying to compile libGE, I get the following problem:

`/usr/include/gcc/darwin/2.95.2/g++/stl_vector.h:'

`In method `_Vector_base<char,allocator<char> >::~_Vector_base()':'

`/usr/include/gcc/darwin/2.95.2/g++/stl_vector.h:115:'

`template instantiation depth exceeds maximum of 17'

   A: This seems to be a limitation of older versions of GCC
(specifically, versions 2.95 or lower). Try using a newer version of
GCC; 3.0 or higher is recommended. (Note: if you have two versions of
GCC on your system, specify which version to use through the
`configure' script; for example, `./configure CC=gcc-3.0 CXX=g++-3.0').

   Q: When running the `configure' script, the check for GALib fails,
but GALib used to run fine on my system.

   A: The version of GCC you are using now might be different than the
one you used when installing GALib on your system. Try recompiling
GALib with the new compiler.

   Q: My grammar loads without any errors, but I am getting non-terminal
symbols in my phenotype strings, why?

   A: Your BNF specification does not conform with the format accepted
by libGE. Check the examples provided (*note Examples::).

   Q: When compiling a program using GALib with SLang, I get the
following error:

`/usr/local/include/ga/GA1DArrayGenome.C:342: error: syntax error before
`>' token'

   A: Both GALib and slang took the unfortunate decision of using the
variable `ARRAY_TYPE' on their files: slang as an equivalent for its own
`SLANG_ARRAY_TYPE', and GALib as a template name. To solve this problem,
make sure you do `#include<ga/ga.h>' before you do `#include<slang.h>'.

   Q: I am getting the following error:

`# libGE has been configured to use GALib, but GALib was not found.   #'

`# Please re-install GALib, or reconfigure libGE and re-install it.   #'

`# Alternatively, edit the libGEdefs.h file in the include directory. #'

   A: When you originally configured and installed libGE, a copy of
GALib was found on your system, and support for GALib was enabled;
however, the GALib headers can no longer be found. This causes the
compilation of any program using libGE headers to fail, even if they do
not use GALib.

   The easiest solution is to reconfigure, recompile and reinstall
libGE.  Otherwise, remove the line defining the symbol
`GALIB_INCLUDEPATH' from the file `libGEdefs.h', which was installed in
the libGE include directory (typically
`/usr/local/include/GE/libGEdefs.h').


File: libGE.info,  Node: Copying This Manual,  Next: References,  Prev: FAQ,  Up: Top

Appendix B Copying This Manual
******************************

B.1 GNU Free Documentation License
==================================

                      Version 1.2, November 2002

     Copyright (C) 2000,2001,2002 Free Software Foundation, Inc.
     59 Temple Place, Suite 330, Boston, MA  02111-1307, USA

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

  0. PREAMBLE

     The purpose of this License is to make a manual, textbook, or other
     functional and useful document "free" in the sense of freedom: to
     assure everyone the effective freedom to copy and redistribute it,
     with or without modifying it, either commercially or
     noncommercially.  Secondarily, this License preserves for the
     author and publisher a way to get credit for their work, while not
     being considered responsible for modifications made by others.

     This License is a kind of "copyleft", which means that derivative
     works of the document must themselves be free in the same sense.
     It complements the GNU General Public License, which is a copyleft
     license designed for free software.

     We have designed this License in order to use it for manuals for
     free software, because free software needs free documentation: a
     free program should come with manuals providing the same freedoms
     that the software does.  But this License is not limited to
     software manuals; it can be used for any textual work, regardless
     of subject matter or whether it is published as a printed book.
     We recommend this License principally for works whose purpose is
     instruction or reference.

  1. APPLICABILITY AND DEFINITIONS

     This License applies to any manual or other work, in any medium,
     that contains a notice placed by the copyright holder saying it
     can be distributed under the terms of this License.  Such a notice
     grants a world-wide, royalty-free license, unlimited in duration,
     to use that work under the conditions stated herein.  The
     "Document", below, refers to any such manual or work.  Any member
     of the public is a licensee, and is addressed as "you".  You
     accept the license if you copy, modify or distribute the work in a
     way requiring permission under copyright law.

     A "Modified Version" of the Document means any work containing the
     Document or a portion of it, either copied verbatim, or with
     modifications and/or translated into another language.

     A "Secondary Section" is a named appendix or a front-matter section
     of the Document that deals exclusively with the relationship of the
     publishers or authors of the Document to the Document's overall
     subject (or to related matters) and contains nothing that could
     fall directly within that overall subject.  (Thus, if the Document
     is in part a textbook of mathematics, a Secondary Section may not
     explain any mathematics.)  The relationship could be a matter of
     historical connection with the subject or with related matters, or
     of legal, commercial, philosophical, ethical or political position
     regarding them.

     The "Invariant Sections" are certain Secondary Sections whose
     titles are designated, as being those of Invariant Sections, in
     the notice that says that the Document is released under this
     License.  If a section does not fit the above definition of
     Secondary then it is not allowed to be designated as Invariant.
     The Document may contain zero Invariant Sections.  If the Document
     does not identify any Invariant Sections then there are none.

     The "Cover Texts" are certain short passages of text that are
     listed, as Front-Cover Texts or Back-Cover Texts, in the notice
     that says that the Document is released under this License.  A
     Front-Cover Text may be at most 5 words, and a Back-Cover Text may
     be at most 25 words.

     A "Transparent" copy of the Document means a machine-readable copy,
     represented in a format whose specification is available to the
     general public, that is suitable for revising the document
     straightforwardly with generic text editors or (for images
     composed of pixels) generic paint programs or (for drawings) some
     widely available drawing editor, and that is suitable for input to
     text formatters or for automatic translation to a variety of
     formats suitable for input to text formatters.  A copy made in an
     otherwise Transparent file format whose markup, or absence of
     markup, has been arranged to thwart or discourage subsequent
     modification by readers is not Transparent.  An image format is
     not Transparent if used for any substantial amount of text.  A
     copy that is not "Transparent" is called "Opaque".

     Examples of suitable formats for Transparent copies include plain
     ASCII without markup, Texinfo input format, LaTeX input format,
     SGML or XML using a publicly available DTD, and
     standard-conforming simple HTML, PostScript or PDF designed for
     human modification.  Examples of transparent image formats include
     PNG, XCF and JPG.  Opaque formats include proprietary formats that
     can be read and edited only by proprietary word processors, SGML or
     XML for which the DTD and/or processing tools are not generally
     available, and the machine-generated HTML, PostScript or PDF
     produced by some word processors for output purposes only.

     The "Title Page" means, for a printed book, the title page itself,
     plus such following pages as are needed to hold, legibly, the
     material this License requires to appear in the title page.  For
     works in formats which do not have any title page as such, "Title
     Page" means the text near the most prominent appearance of the
     work's title, preceding the beginning of the body of the text.

     A section "Entitled XYZ" means a named subunit of the Document
     whose title either is precisely XYZ or contains XYZ in parentheses
     following text that translates XYZ in another language.  (Here XYZ
     stands for a specific section name mentioned below, such as
     "Acknowledgements", "Dedications", "Endorsements", or "History".)
     To "Preserve the Title" of such a section when you modify the
     Document means that it remains a section "Entitled XYZ" according
     to this definition.

     The Document may include Warranty Disclaimers next to the notice
     which states that this License applies to the Document.  These
     Warranty Disclaimers are considered to be included by reference in
     this License, but only as regards disclaiming warranties: any other
     implication that these Warranty Disclaimers may have is void and
     has no effect on the meaning of this License.

  2. VERBATIM COPYING

     You may copy and distribute the Document in any medium, either
     commercially or noncommercially, provided that this License, the
     copyright notices, and the license notice saying this License
     applies to the Document are reproduced in all copies, and that you
     add no other conditions whatsoever to those of this License.  You
     may not use technical measures to obstruct or control the reading
     or further copying of the copies you make or distribute.  However,
     you may accept compensation in exchange for copies.  If you
     distribute a large enough number of copies you must also follow
     the conditions in section 3.

     You may also lend copies, under the same conditions stated above,
     and you may publicly display copies.

  3. COPYING IN QUANTITY

     If you publish printed copies (or copies in media that commonly
     have printed covers) of the Document, numbering more than 100, and
     the Document's license notice requires Cover Texts, you must
     enclose the copies in covers that carry, clearly and legibly, all
     these Cover Texts: Front-Cover Texts on the front cover, and
     Back-Cover Texts on the back cover.  Both covers must also clearly
     and legibly identify you as the publisher of these copies.  The
     front cover must present the full title with all words of the
     title equally prominent and visible.  You may add other material
     on the covers in addition.  Copying with changes limited to the
     covers, as long as they preserve the title of the Document and
     satisfy these conditions, can be treated as verbatim copying in
     other respects.

     If the required texts for either cover are too voluminous to fit
     legibly, you should put the first ones listed (as many as fit
     reasonably) on the actual cover, and continue the rest onto
     adjacent pages.

     If you publish or distribute Opaque copies of the Document
     numbering more than 100, you must either include a
     machine-readable Transparent copy along with each Opaque copy, or
     state in or with each Opaque copy a computer-network location from
     which the general network-using public has access to download
     using public-standard network protocols a complete Transparent
     copy of the Document, free of added material.  If you use the
     latter option, you must take reasonably prudent steps, when you
     begin distribution of Opaque copies in quantity, to ensure that
     this Transparent copy will remain thus accessible at the stated
     location until at least one year after the last time you
     distribute an Opaque copy (directly or through your agents or
     retailers) of that edition to the public.

     It is requested, but not required, that you contact the authors of
     the Document well before redistributing any large number of
     copies, to give them a chance to provide you with an updated
     version of the Document.

  4. MODIFICATIONS

     You may copy and distribute a Modified Version of the Document
     under the conditions of sections 2 and 3 above, provided that you
     release the Modified Version under precisely this License, with
     the Modified Version filling the role of the Document, thus
     licensing distribution and modification of the Modified Version to
     whoever possesses a copy of it.  In addition, you must do these
     things in the Modified Version:

       A. Use in the Title Page (and on the covers, if any) a title
          distinct from that of the Document, and from those of
          previous versions (which should, if there were any, be listed
          in the History section of the Document).  You may use the
          same title as a previous version if the original publisher of
          that version gives permission.

       B. List on the Title Page, as authors, one or more persons or
          entities responsible for authorship of the modifications in
          the Modified Version, together with at least five of the
          principal authors of the Document (all of its principal
          authors, if it has fewer than five), unless they release you
          from this requirement.

       C. State on the Title page the name of the publisher of the
          Modified Version, as the publisher.

       D. Preserve all the copyright notices of the Document.

       E. Add an appropriate copyright notice for your modifications
          adjacent to the other copyright notices.

       F. Include, immediately after the copyright notices, a license
          notice giving the public permission to use the Modified
          Version under the terms of this License, in the form shown in
          the Addendum below.

       G. Preserve in that license notice the full lists of Invariant
          Sections and required Cover Texts given in the Document's
          license notice.

       H. Include an unaltered copy of this License.

       I. Preserve the section Entitled "History", Preserve its Title,
          and add to it an item stating at least the title, year, new
          authors, and publisher of the Modified Version as given on
          the Title Page.  If there is no section Entitled "History" in
          the Document, create one stating the title, year, authors,
          and publisher of the Document as given on its Title Page,
          then add an item describing the Modified Version as stated in
          the previous sentence.

       J. Preserve the network location, if any, given in the Document
          for public access to a Transparent copy of the Document, and
          likewise the network locations given in the Document for
          previous versions it was based on.  These may be placed in
          the "History" section.  You may omit a network location for a
          work that was published at least four years before the
          Document itself, or if the original publisher of the version
          it refers to gives permission.

       K. For any section Entitled "Acknowledgements" or "Dedications",
          Preserve the Title of the section, and preserve in the
          section all the substance and tone of each of the contributor
          acknowledgements and/or dedications given therein.

       L. Preserve all the Invariant Sections of the Document,
          unaltered in their text and in their titles.  Section numbers
          or the equivalent are not considered part of the section
          titles.

       M. Delete any section Entitled "Endorsements".  Such a section
          may not be included in the Modified Version.

       N. Do not retitle any existing section to be Entitled
          "Endorsements" or to conflict in title with any Invariant
          Section.

       O. Preserve any Warranty Disclaimers.

     If the Modified Version includes new front-matter sections or
     appendices that qualify as Secondary Sections and contain no
     material copied from the Document, you may at your option
     designate some or all of these sections as invariant.  To do this,
     add their titles to the list of Invariant Sections in the Modified
     Version's license notice.  These titles must be distinct from any
     other section titles.

     You may add a section Entitled "Endorsements", provided it contains
     nothing but endorsements of your Modified Version by various
     parties--for example, statements of peer review or that the text
     has been approved by an organization as the authoritative
     definition of a standard.

     You may add a passage of up to five words as a Front-Cover Text,
     and a passage of up to 25 words as a Back-Cover Text, to the end
     of the list of Cover Texts in the Modified Version.  Only one
     passage of Front-Cover Text and one of Back-Cover Text may be
     added by (or through arrangements made by) any one entity.  If the
     Document already includes a cover text for the same cover,
     previously added by you or by arrangement made by the same entity
     you are acting on behalf of, you may not add another; but you may
     replace the old one, on explicit permission from the previous
     publisher that added the old one.

     The author(s) and publisher(s) of the Document do not by this
     License give permission to use their names for publicity for or to
     assert or imply endorsement of any Modified Version.

  5. COMBINING DOCUMENTS

     You may combine the Document with other documents released under
     this License, under the terms defined in section 4 above for
     modified versions, provided that you include in the combination
     all of the Invariant Sections of all of the original documents,
     unmodified, and list them all as Invariant Sections of your
     combined work in its license notice, and that you preserve all
     their Warranty Disclaimers.

     The combined work need only contain one copy of this License, and
     multiple identical Invariant Sections may be replaced with a single
     copy.  If there are multiple Invariant Sections with the same name
     but different contents, make the title of each such section unique
     by adding at the end of it, in parentheses, the name of the
     original author or publisher of that section if known, or else a
     unique number.  Make the same adjustment to the section titles in
     the list of Invariant Sections in the license notice of the
     combined work.

     In the combination, you must combine any sections Entitled
     "History" in the various original documents, forming one section
     Entitled "History"; likewise combine any sections Entitled
     "Acknowledgements", and any sections Entitled "Dedications".  You
     must delete all sections Entitled "Endorsements."

  6. COLLECTIONS OF DOCUMENTS

     You may make a collection consisting of the Document and other
     documents released under this License, and replace the individual
     copies of this License in the various documents with a single copy
     that is included in the collection, provided that you follow the
     rules of this License for verbatim copying of each of the
     documents in all other respects.

     You may extract a single document from such a collection, and
     distribute it individually under this License, provided you insert
     a copy of this License into the extracted document, and follow
     this License in all other respects regarding verbatim copying of
     that document.

  7. AGGREGATION WITH INDEPENDENT WORKS

     A compilation of the Document or its derivatives with other
     separate and independent documents or works, in or on a volume of
     a storage or distribution medium, is called an "aggregate" if the
     copyright resulting from the compilation is not used to limit the
     legal rights of the compilation's users beyond what the individual
     works permit.  When the Document is included an aggregate, this
     License does not apply to the other works in the aggregate which
     are not themselves derivative works of the Document.

     If the Cover Text requirement of section 3 is applicable to these
     copies of the Document, then if the Document is less than one half
     of the entire aggregate, the Document's Cover Texts may be placed
     on covers that bracket the Document within the aggregate, or the
     electronic equivalent of covers if the Document is in electronic
     form.  Otherwise they must appear on printed covers that bracket
     the whole aggregate.

  8. TRANSLATION

     Translation is considered a kind of modification, so you may
     distribute translations of the Document under the terms of section
     4.  Replacing Invariant Sections with translations requires special
     permission from their copyright holders, but you may include
     translations of some or all Invariant Sections in addition to the
     original versions of these Invariant Sections.  You may include a
     translation of this License, and all the license notices in the
     Document, and any Warrany Disclaimers, provided that you also
     include the original English version of this License and the
     original versions of those notices and disclaimers.  In case of a
     disagreement between the translation and the original version of
     this License or a notice or disclaimer, the original version will
     prevail.

     If a section in the Document is Entitled "Acknowledgements",
     "Dedications", or "History", the requirement (section 4) to
     Preserve its Title (section 1) will typically require changing the
     actual title.

  9. TERMINATION

     You may not copy, modify, sublicense, or distribute the Document
     except as expressly provided for under this License.  Any other
     attempt to copy, modify, sublicense or distribute the Document is
     void, and will automatically terminate your rights under this
     License.  However, parties who have received copies, or rights,
     from you under this License will not have their licenses
     terminated so long as such parties remain in full compliance.

 10. FUTURE REVISIONS OF THIS LICENSE

     The Free Software Foundation may publish new, revised versions of
     the GNU Free Documentation License from time to time.  Such new
     versions will be similar in spirit to the present version, but may
     differ in detail to address new problems or concerns.  See
     `http://www.gnu.org/copyleft/'.

     Each version of the License is given a distinguishing version
     number.  If the Document specifies that a particular numbered
     version of this License "or any later version" applies to it, you
     have the option of following the terms and conditions either of
     that specified version or of any later version that has been
     published (not as a draft) by the Free Software Foundation.  If
     the Document does not specify a version number of this License,
     you may choose any version ever published (not as a draft) by the
     Free Software Foundation.


File: libGE.info,  Node: References,  Next: Index,  Prev: Copying This Manual,  Up: Top

Appendix C References
*********************

D. E. Goldberg: Genetic Algorithms in Search, Optimization and Machine
   Learning. Addison Wesley. (1989)

   M. O'Neill: Automatic Programming in an Arbitrary Language: Evolving
   Programs with Grammatical Evolution. PhD Thesis, University of
Limerick (2001)

   M. O'Neill and C. Ryan: Grammatical Evolution. IEEE Transactions on
   Evolutionary Computation, Vol. 5, No. 4. (2001) 349-358

   M. O'Neill and C. Ryan: Grammatical Evolution - Evolving programs in
an
   arbitrary language. Kluwer Academic Publishers. (2003)

   R. E. Smith, D. E. Goldberg and J. A. Earickson: SGA-C: A C-language
   Implementation of a Simple Genetic Algorithm. TCGA Report No. 91002.
(1994)

   C. Ryan and A. Azad: Sensible Initialisation in Grammatical
Evolution. In:
   GEWS 2003: Grammatical Evolution Workshop, GECCO-2003, Chicago, USA.
(2003)


File: libGE.info,  Node: Index,  Prev: References,  Up: Top

Concept Index
*************

 [index ]
* Menu:

* <GECodonValue>:                        libGE Extensions.    (line  30)
* Backus-Naur Form:                      Grammars.            (line  13)
* BNF <1>:                               Format of Grammars.  (line   6)
* BNF <2>:                               Grammars.            (line  13)
* BNF:                                   Grammatical Evolution.
                                                              (line   6)
* BNF grammar:                           Purpose.             (line   6)
* BNF grammar, examples:                 Examples of Grammars.
                                                              (line   6)
* CFG:                                   Type of Grammars.    (line   9)
* Class hierarchy:                       Class Hierarchy.     (line   6)
* Closed Grammars:                       Type of Grammars.    (line  88)
* Context-Free Grammars:                 Type of Grammars.    (line   9)
* Evaluators:                            Evaluators.          (line   6)
* Examples:                              Examples.            (line   6)
* FAQ:                                   FAQ.                 (line   6)
* FDL, GNU Free Documentation License:   Copying This Manual. (line   9)
* Frequently Asked Questions:            FAQ.                 (line   6)
* GE:                                    Grammatical Evolution.
                                                              (line   6)
* GECodonValue:                          libGE Extensions.    (line  30)
* Genotype to Phenotype mapping:         Grammatical Evolution.
                                                              (line  66)
* Genotypic structure <1>:               EXAMPLES/CartCentering/GE_ILLIGALSGA/app.c.
                                                              (line   6)
* Genotypic structure <2>:               EXAMPLES/SantaFeAntTrail/GE_ILLIGALSGA/app.c.
                                                              (line   6)
* Genotypic structure:                   Purpose.             (line   6)
* Grammar examples <1>:                  Examples of Grammars.
                                                              (line   6)
* Grammar examples:                      Grammatical Evolution.
                                                              (line 100)
* Grammar extensions:                    libGE Extensions.    (line   6)
* Grammars:                              Grammars.            (line   6)
* Grammatical Evolution:                 Grammatical Evolution.
                                                              (line   6)
* Interface:                             Programming Interface.
                                                              (line   6)
* Mapping process:                       Example of Mapping Process.
                                                              (line   6)
* Overview:                              Overview.            (line   6)
* Phenotypic structure:                  Purpose.             (line   6)
* Production:                            Format of Grammars.  (line  76)
* Programming Interface:                 Programming Interface.
                                                              (line   6)
* Regular Grammars:                      Type of Grammars.    (line  68)
* Rule:                                  Format of Grammars.  (line  64)
* Search Engines:                        Search Engines.      (line   6)
* Start Symbol:                          Format of Grammars.  (line 110)
* Symbol:                                Format of Grammars.  (line  89)
* Wrapping:                              Example of Mapping Process.
                                                              (line  58)
* XML grammars:                          Format of Grammars.  (line   6)

Function Index
**************

 [index ]
* Menu:

* addBNFString(), CFGrammar:             CFGrammar.           (line  67)
* app_init() <1>:                        EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-lua.cpp.
                                                              (line  31)
* app_init() <2>:                        EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-libtcc.cpp.
                                                              (line  16)
* app_init() <3>:                        EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-slang.cpp.
                                                              (line  11)
* app_init() <4>:                        EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-gcc.cpp.
                                                              (line  13)
* app_init() <5>:                        EXAMPLES/IntertwinedSpirals/GE_MITGALIB/main.cpp.
                                                              (line  55)
* app_init() <6>:                        EXAMPLES/CartCentering/GE_MITGALIB/cartcenter-lua.cpp.
                                                              (line  31)
* app_init() <7>:                        EXAMPLES/CartCentering/GE_MITGALIB/cartcenter-libtcc.cpp.
                                                              (line  16)
* app_init() <8>:                        EXAMPLES/CartCentering/GE_MITGALIB/cartcenter-slang.cpp.
                                                              (line  11)
* app_init() <9>:                        EXAMPLES/CartCentering/GE_MITGALIB/cartcenter-gcc.cpp.
                                                              (line  12)
* app_init() <10>:                       EXAMPLES/CartCentering/GE_MITGALIB/main.cpp.
                                                              (line  75)
* app_init() <11>:                       EXAMPLES/CartCentering/GE_ILLIGALSGA/app.c.
                                                              (line   6)
* app_init() <12>:                       EXAMPLES/SantaFeAntTrail/GE_MITGALIB/santafe-lua.cpp.
                                                              (line  14)
* app_init() <13>:                       EXAMPLES/SantaFeAntTrail/GE_MITGALIB/santafe-tcc.cpp.
                                                              (line  12)
* app_init() <14>:                       EXAMPLES/SantaFeAntTrail/GE_MITGALIB/santafe-slang.cpp.
                                                              (line  11)
* app_init() <15>:                       EXAMPLES/SantaFeAntTrail/GE_MITGALIB/santafe-gcc.cpp.
                                                              (line  12)
* app_init() <16>:                       EXAMPLES/SantaFeAntTrail/GE_MITGALIB/main.cpp.
                                                              (line  31)
* app_init():                            EXAMPLES/SantaFeAntTrail/GE_ILLIGALSGA/app.c.
                                                              (line   6)
* buildDTree(), GEGrammar:               GEGrammar.           (line  60)
* CFGrammar:                             CFGrammar.           (line   6)
* CFGrammar.addBNFString():              CFGrammar.           (line  67)
* CFGrammar.clearRuleFields():           CFGrammar.           (line  93)
* CFGrammar.findRule():                  CFGrammar.           (line  78)
* CFGrammar.getDerivationTree():         CFGrammar.           (line  82)
* CFGrammar.isRecursive():               CFGrammar.           (line  86)
* CFGrammar.outputBNF():                 CFGrammar.           (line  75)
* CFGrammar.readBNFFile():               CFGrammar.           (line  53)
* CFGrammar.readBNFString():             CFGrammar.           (line  60)
* CFGrammar.updateRuleFields():          CFGrammar.           (line  90)
* clear(), Production:                   Production.          (line  38)
* clear(), Rule:                         Rule.                (line  39)
* clear(), Tree:                         Tree.                (line  68)
* clearRuleFields(), CFGrammar:          CFGrammar.           (line  93)
* effCrossover() <1>:                    EXAMPLES/IntertwinedSpirals/GE_MITGALIB/GEListGenome.h.
                                                              (line  12)
* effCrossover() <2>:                    EXAMPLES/IntertwinedSpirals/GE_MITGALIB/main.cpp.
                                                              (line  34)
* effCrossover() <3>:                    EXAMPLES/CartCentering/GE_MITGALIB/GEListGenome.h.
                                                              (line  12)
* effCrossover() <4>:                    EXAMPLES/CartCentering/GE_MITGALIB/main.cpp.
                                                              (line  34)
* effCrossover() <5>:                    EXAMPLES/SantaFeAntTrail/GE_MITGALIB/GEListGenome.h.
                                                              (line  12)
* effCrossover():                        EXAMPLES/SantaFeAntTrail/GE_MITGALIB/main.cpp.
                                                              (line  23)
* findRule(), CFGrammar:                 CFGrammar.           (line  78)
* GEGrammar:                             GEGrammar.           (line   6)
* GEGrammar.buildDTree():                GEGrammar.           (line  60)
* GEGrammar.genotype2Phenotype():        GEGrammar.           (line  64)
* GEGrammar.genotype2PhenotypeStep():    GEGrammar.           (line  77)
* GEGrammar.getDerivationTree():         GEGrammar.           (line  53)
* GEGrammar.getMaxWraps():               GEGrammar.           (line  47)
* GEGrammar.getProductions():            GEGrammar.           (line  57)
* GEGrammar.phenotype2Genotype():        GEGrammar.           (line  70)
* GEGrammar.setMaxWraps():               GEGrammar.           (line  50)
* GEGrammarSI:                           GEGrammarSI.         (line   6)
* GEGrammarSI.getFull():                 GEGrammarSI.         (line  63)
* GEGrammarSI.getGrow():                 GEGrammarSI.         (line  57)
* GEGrammarSI.getMaxDepth():             GEGrammarSI.         (line  69)
* GEGrammarSI.getTailRatio():            GEGrammarSI.         (line  75)
* GEGrammarSI.getTailSize():             GEGrammarSI.         (line  82)
* GEGrammarSI.growTree():                GEGrammarSI.         (line  89)
* GEGrammarSI.init() <1>:                EXAMPLES/IntertwinedSpirals/GE_EO/eoGEInit.h.
                                                              (line  15)
* GEGrammarSI.init() <2>:                EXAMPLES/IntertwinedSpirals/GE_MITGALIB/initfunc.cpp.
                                                              (line  14)
* GEGrammarSI.init() <3>:                EXAMPLES/CartCentering/GE_EO/eoGEInit.h.
                                                              (line  15)
* GEGrammarSI.init() <4>:                EXAMPLES/CartCentering/GE_MITGALIB/initfunc.cpp.
                                                              (line  14)
* GEGrammarSI.init() <5>:                EXAMPLES/SantaFeAntTrail/GE_EO/eoGEInit.h.
                                                              (line  16)
* GEGrammarSI.init() <6>:                EXAMPLES/SantaFeAntTrail/GE_MITGALIB/initfunc.cpp.
                                                              (line  15)
* GEGrammarSI.init():                    GEGrammarSI.         (line  93)
* GEGrammarSI.setFull():                 GEGrammarSI.         (line  66)
* GEGrammarSI.setGrow():                 GEGrammarSI.         (line  60)
* GEGrammarSI.setMaxDepth():             GEGrammarSI.         (line  72)
* GEGrammarSI.setTailRatio():            GEGrammarSI.         (line  78)
* GEGrammarSI.setTailSize():             GEGrammarSI.         (line  85)
* Genotype:                              Genotype.            (line   6)
* Genotype.getEffectiveSize():           Genotype.            (line  84)
* Genotype.getFitness():                 Genotype.            (line  72)
* Genotype.getMaxCodonValue():           Genotype.            (line  78)
* Genotype.getValid():                   Genotype.            (line  67)
* Genotype.getWraps():                   Genotype.            (line  90)
* Genotype.operator<<():                 Genotype.            (line  96)
* Genotype.setEffectiveSize():           Genotype.            (line  87)
* Genotype.setFitness():                 Genotype.            (line  75)
* Genotype.setMaxCodonValue():           Genotype.            (line  81)
* Genotype.setValid():                   Genotype.            (line  69)
* Genotype.setWraps():                   Genotype.            (line  93)
* genotype2Phenotype(), GEGrammar:       GEGrammar.           (line  64)
* genotype2PhenotypeStep(), GEGrammar:   GEGrammar.           (line  77)
* getCurrentLevel(), Tree:               Tree.                (line  55)
* getData(), Tree:                       Tree.                (line  60)
* getDepth(), Tree:                      Tree.                (line  49)
* getDerivationTree(), CFGrammar:        CFGrammar.           (line  82)
* getDerivationTree(), GEGrammar:        GEGrammar.           (line  53)
* getEffectiveSize() <1>:                EXAMPLES/IntertwinedSpirals/GE_MITGALIB/GEListGenome.h.
                                                              (line  12)
* getEffectiveSize() <2>:                EXAMPLES/CartCentering/GE_MITGALIB/GEListGenome.h.
                                                              (line  12)
* getEffectiveSize():                    EXAMPLES/SantaFeAntTrail/GE_MITGALIB/GEListGenome.h.
                                                              (line  12)
* getEffectiveSize(), Genotype:          Genotype.            (line  84)
* getFitness(), Genotype:                Genotype.            (line  72)
* getFitness(), Phenotype:               Phenotype.           (line  50)
* getFull(), GEGrammarSI:                GEGrammarSI.         (line  63)
* getGenotype(), Mapper:                 Mapper.              (line  53)
* getGrow(), GEGrammarSI:                GEGrammarSI.         (line  57)
* getIndex(), Initialiser:               Initialiser.         (line  46)
* getMaxCodonValue(), Genotype:          Genotype.            (line  78)
* getMaxDepth(), GEGrammarSI:            GEGrammarSI.         (line  69)
* getMaxWraps(), GEGrammar:              GEGrammar.           (line  47)
* getMinimumDepth(), Production:         Production.          (line  47)
* getMinimumDepth(), Rule:               Rule.                (line  48)
* getPhenotype(), Mapper:                Mapper.              (line  70)
* getPopSize(), Initialiser:             Initialiser.         (line  40)
* getProductions(), GEGrammar:           GEGrammar.           (line  57)
* getRecursive(), Production:            Production.          (line  41)
* getRecursive(), Rule:                  Rule.                (line  42)
* getStartRule(), Grammar:               Grammar.             (line  70)
* getStartSymbol(), Grammar:             Grammar.             (line  58)
* getString(), Phenotype:                Phenotype.           (line  56)
* getTailRatio(), GEGrammarSI:           GEGrammarSI.         (line  75)
* getTailSize(), GEGrammarSI:            GEGrammarSI.         (line  82)
* getType(), Symbol:                     Symbol.              (line  43)
* getValid(), Genotype:                  Genotype.            (line  67)
* getValid(), Phenotype:                 Phenotype.           (line  45)
* getValid(), Tree:                      Tree.                (line  64)
* getValidGrammar(), Grammar:            Grammar.             (line  52)
* getWraps(), Genotype:                  Genotype.            (line  90)
* Grammar:                               Grammar.             (line   6)
* Grammar.getStartRule():                Grammar.             (line  70)
* Grammar.getStartSymbol():              Grammar.             (line  58)
* Grammar.getValidGrammar():             Grammar.             (line  52)
* Grammar.setStartSymbol():              Grammar.             (line  61)
* Grammar.setValidGrammar():             Grammar.             (line  55)
* growTree(), GEGrammarSI:               GEGrammarSI.         (line  89)
* init(), GEGrammarSI <1>:               EXAMPLES/IntertwinedSpirals/GE_EO/eoGEInit.h.
                                                              (line  15)
* init(), GEGrammarSI <2>:               EXAMPLES/IntertwinedSpirals/GE_MITGALIB/initfunc.cpp.
                                                              (line  14)
* init(), GEGrammarSI <3>:               EXAMPLES/CartCentering/GE_EO/eoGEInit.h.
                                                              (line  15)
* init(), GEGrammarSI <4>:               EXAMPLES/CartCentering/GE_MITGALIB/initfunc.cpp.
                                                              (line  14)
* init(), GEGrammarSI <5>:               EXAMPLES/SantaFeAntTrail/GE_EO/eoGEInit.h.
                                                              (line  16)
* init(), GEGrammarSI <6>:               EXAMPLES/SantaFeAntTrail/GE_MITGALIB/initfunc.cpp.
                                                              (line  15)
* init(), GEGrammarSI:                   GEGrammarSI.         (line  93)
* initFuncRandom() <1>:                  EXAMPLES/IntertwinedSpirals/GE_MITGALIB/initfunc.cpp.
                                                              (line   6)
* initFuncRandom() <2>:                  EXAMPLES/IntertwinedSpirals/GE_MITGALIB/main.cpp.
                                                              (line  34)
* initFuncRandom() <3>:                  EXAMPLES/CartCentering/GE_MITGALIB/initfunc.cpp.
                                                              (line   6)
* initFuncRandom() <4>:                  EXAMPLES/CartCentering/GE_MITGALIB/main.cpp.
                                                              (line  34)
* initFuncRandom() <5>:                  EXAMPLES/SantaFeAntTrail/GE_MITGALIB/initfunc.cpp.
                                                              (line   6)
* initFuncRandom():                      EXAMPLES/SantaFeAntTrail/GE_MITGALIB/main.cpp.
                                                              (line  23)
* initFuncSI() <1>:                      EXAMPLES/IntertwinedSpirals/GE_MITGALIB/initfunc.cpp.
                                                              (line  14)
* initFuncSI() <2>:                      EXAMPLES/IntertwinedSpirals/GE_MITGALIB/main.cpp.
                                                              (line  34)
* initFuncSI() <3>:                      EXAMPLES/CartCentering/GE_MITGALIB/initfunc.cpp.
                                                              (line  14)
* initFuncSI() <4>:                      EXAMPLES/CartCentering/GE_MITGALIB/main.cpp.
                                                              (line  34)
* initFuncSI() <5>:                      EXAMPLES/SantaFeAntTrail/GE_MITGALIB/initfunc.cpp.
                                                              (line  15)
* initFuncSI():                          EXAMPLES/SantaFeAntTrail/GE_MITGALIB/main.cpp.
                                                              (line  23)
* Initialiser:                           Initialiser.         (line   6)
* Initialiser.getIndex():                Initialiser.         (line  46)
* Initialiser.getPopSize():              Initialiser.         (line  40)
* Initialiser.setIndex():                Initialiser.         (line  49)
* Initialiser.setPopSize():              Initialiser.         (line  43)
* isRecursive(), CFGrammar:              CFGrammar.           (line  86)
* lua_getglobal() <1>:                   EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-lua.h.
                                                              (line  92)
* lua_getglobal() <2>:                   EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-lua.cpp.
                                                              (line  91)
* lua_getglobal() <3>:                   EXAMPLES/CartCentering/GE_EO/eoGEEvalFunc-lua.h.
                                                              (line  92)
* lua_getglobal() <4>:                   EXAMPLES/CartCentering/GE_MITGALIB/cartcenter-lua.cpp.
                                                              (line  90)
* lua_getglobal() <5>:                   EXAMPLES/SantaFeAntTrail/GE_EO/eoGEEvalFuncLua.h.
                                                              (line  24)
* lua_getglobal():                       EXAMPLES/SantaFeAntTrail/GE_MITGALIB/santafe-lua.cpp.
                                                              (line  26)
* lua_isnumber() <1>:                    EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-lua.h.
                                                              (line  92)
* lua_isnumber() <2>:                    EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-lua.cpp.
                                                              (line  91)
* lua_isnumber() <3>:                    EXAMPLES/CartCentering/GE_EO/eoGEEvalFunc-lua.h.
                                                              (line  92)
* lua_isnumber():                        EXAMPLES/CartCentering/GE_MITGALIB/cartcenter-lua.cpp.
                                                              (line  90)
* lua_open() <1>:                        EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-lua.h.
                                                              (line  41)
* lua_open() <2>:                        EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-lua.cpp.
                                                              (line  44)
* lua_open() <3>:                        EXAMPLES/CartCentering/GE_EO/eoGEEvalFunc-lua.h.
                                                              (line  42)
* lua_open() <4>:                        EXAMPLES/CartCentering/GE_MITGALIB/cartcenter-lua.cpp.
                                                              (line  44)
* lua_open() <5>:                        EXAMPLES/SantaFeAntTrail/GE_EO/eoGEEvalFuncLua.h.
                                                              (line  12)
* lua_open():                            EXAMPLES/SantaFeAntTrail/GE_MITGALIB/santafe-lua.cpp.
                                                              (line  14)
* lua_pcall() <1>:                       EXAMPLES/SantaFeAntTrail/GE_EO/eoGEEvalFuncLua.h.
                                                              (line  12)
* lua_pcall():                           EXAMPLES/SantaFeAntTrail/GE_MITGALIB/santafe-lua.cpp.
                                                              (line  14)
* lua_tonumber() <1>:                    EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-lua.h.
                                                              (line  92)
* lua_tonumber() <2>:                    EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-lua.cpp.
                                                              (line  91)
* lua_tonumber() <3>:                    EXAMPLES/CartCentering/GE_EO/eoGEEvalFunc-lua.h.
                                                              (line  92)
* lua_tonumber() <4>:                    EXAMPLES/CartCentering/GE_MITGALIB/cartcenter-lua.cpp.
                                                              (line  90)
* lua_tonumber() <5>:                    EXAMPLES/SantaFeAntTrail/GE_EO/eoGEEvalFuncLua.h.
                                                              (line  24)
* lua_tonumber():                        EXAMPLES/SantaFeAntTrail/GE_MITGALIB/santafe-lua.cpp.
                                                              (line  26)
* lua_tostring() <1>:                    EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-lua.h.
                                                              (line  46)
* lua_tostring() <2>:                    EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-lua.cpp.
                                                              (line  49)
* lua_tostring() <3>:                    EXAMPLES/CartCentering/GE_EO/eoGEEvalFunc-lua.h.
                                                              (line  47)
* lua_tostring():                        EXAMPLES/CartCentering/GE_MITGALIB/cartcenter-lua.cpp.
                                                              (line  49)
* luaL_dofile() <1>:                     EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-lua.h.
                                                              (line  46)
* luaL_dofile() <2>:                     EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-lua.cpp.
                                                              (line  49)
* luaL_dofile() <3>:                     EXAMPLES/CartCentering/GE_EO/eoGEEvalFunc-lua.h.
                                                              (line  47)
* luaL_dofile():                         EXAMPLES/CartCentering/GE_MITGALIB/cartcenter-lua.cpp.
                                                              (line  49)
* luaL_dostring() <1>:                   EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-lua.h.
                                                              (line  86)
* luaL_dostring() <2>:                   EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-lua.cpp.
                                                              (line  85)
* luaL_dostring() <3>:                   EXAMPLES/CartCentering/GE_EO/eoGEEvalFunc-lua.h.
                                                              (line  86)
* luaL_dostring():                       EXAMPLES/CartCentering/GE_MITGALIB/cartcenter-lua.cpp.
                                                              (line  84)
* luaL_loadbuffer() <1>:                 EXAMPLES/SantaFeAntTrail/GE_EO/eoGEEvalFuncLua.h.
                                                              (line  12)
* luaL_loadbuffer():                     EXAMPLES/SantaFeAntTrail/GE_MITGALIB/santafe-lua.cpp.
                                                              (line  14)
* luaL_loadfile() <1>:                   EXAMPLES/SantaFeAntTrail/GE_EO/eoGEEvalFuncLua.h.
                                                              (line  12)
* luaL_loadfile():                       EXAMPLES/SantaFeAntTrail/GE_MITGALIB/santafe-lua.cpp.
                                                              (line  14)
* luaL_openlibs() <1>:                   EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-lua.h.
                                                              (line  41)
* luaL_openlibs() <2>:                   EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-lua.cpp.
                                                              (line  44)
* luaL_openlibs() <3>:                   EXAMPLES/CartCentering/GE_EO/eoGEEvalFunc-lua.h.
                                                              (line  42)
* luaL_openlibs():                       EXAMPLES/CartCentering/GE_MITGALIB/cartcenter-lua.cpp.
                                                              (line  44)
* luaopen_base() <1>:                    EXAMPLES/SantaFeAntTrail/GE_EO/eoGEEvalFuncLua.h.
                                                              (line  12)
* luaopen_base():                        EXAMPLES/SantaFeAntTrail/GE_MITGALIB/santafe-lua.cpp.
                                                              (line  14)
* luaopen_io() <1>:                      EXAMPLES/SantaFeAntTrail/GE_EO/eoGEEvalFuncLua.h.
                                                              (line  12)
* luaopen_io():                          EXAMPLES/SantaFeAntTrail/GE_MITGALIB/santafe-lua.cpp.
                                                              (line  14)
* luaopen_string() <1>:                  EXAMPLES/SantaFeAntTrail/GE_EO/eoGEEvalFuncLua.h.
                                                              (line  12)
* luaopen_string():                      EXAMPLES/SantaFeAntTrail/GE_MITGALIB/santafe-lua.cpp.
                                                              (line  14)
* Mapper:                                Mapper.              (line   6)
* Mapper.getGenotype():                  Mapper.              (line  53)
* Mapper.getPhenotype():                 Mapper.              (line  70)
* Mapper.setGenotype():                  Mapper.              (line  56)
* Mapper.setGenotypeMaxCodonValue():     Mapper.              (line  78)
* Mapper.setPhenotype():                 Mapper.              (line  73)
* objfunc() <1>:                         EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-lua.cpp.
                                                              (line  63)
* objfunc() <2>:                         EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-libtcc.cpp.
                                                              (line  43)
* objfunc() <3>:                         EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-slang.cpp.
                                                              (line  34)
* objfunc() <4>:                         EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-gcc.cpp.
                                                              (line  34)
* objfunc() <5>:                         EXAMPLES/IntertwinedSpirals/GE_MITGALIB/main.cpp.
                                                              (line   6)
* objfunc() <6>:                         EXAMPLES/CartCentering/GE_MITGALIB/cartcenter-lua.cpp.
                                                              (line  63)
* objfunc() <7>:                         EXAMPLES/CartCentering/GE_MITGALIB/cartcenter-libtcc.cpp.
                                                              (line  45)
* objfunc() <8>:                         EXAMPLES/CartCentering/GE_MITGALIB/cartcenter-slang.cpp.
                                                              (line  41)
* objfunc() <9>:                         EXAMPLES/CartCentering/GE_MITGALIB/cartcenter-gcc.cpp.
                                                              (line  34)
* objfunc() <10>:                        EXAMPLES/CartCentering/GE_MITGALIB/main.cpp.
                                                              (line   6)
* objfunc() <11>:                        EXAMPLES/CartCentering/GE_ILLIGALSGA/app.c.
                                                              (line   6)
* objfunc() <12>:                        EXAMPLES/SantaFeAntTrail/GE_MITGALIB/santafe-lua.cpp.
                                                              (line  26)
* objfunc() <13>:                        EXAMPLES/SantaFeAntTrail/GE_MITGALIB/santafe-tcc.cpp.
                                                              (line  18)
* objfunc() <14>:                        EXAMPLES/SantaFeAntTrail/GE_MITGALIB/santafe-slang.cpp.
                                                              (line  23)
* objfunc() <15>:                        EXAMPLES/SantaFeAntTrail/GE_MITGALIB/santafe-gcc.cpp.
                                                              (line  18)
* objfunc() <16>:                        EXAMPLES/SantaFeAntTrail/GE_MITGALIB/main.cpp.
                                                              (line   6)
* objfunc():                             EXAMPLES/SantaFeAntTrail/GE_ILLIGALSGA/app.c.
                                                              (line   6)
* OnePointCrossover() <1>:               EXAMPLES/IntertwinedSpirals/GE_MITGALIB/main.cpp.
                                                              (line  34)
* OnePointCrossover() <2>:               EXAMPLES/CartCentering/GE_MITGALIB/main.cpp.
                                                              (line  34)
* OnePointCrossover():                   EXAMPLES/SantaFeAntTrail/GE_MITGALIB/main.cpp.
                                                              (line  23)
* operator<<(), Genotype:                Genotype.            (line  96)
* operator<<(), Phenotype:               Phenotype.           (line  59)
* operator<<(), Production:              Production.          (line  53)
* operator=(), Symbol:                   Symbol.              (line  49)
* operator==(), Symbol:                  Symbol.              (line  51)
* outputBNF(), CFGrammar:                CFGrammar.           (line  75)
* Phenotype:                             Phenotype.           (line   6)
* Phenotype.getFitness():                Phenotype.           (line  50)
* Phenotype.getString():                 Phenotype.           (line  56)
* Phenotype.getValid():                  Phenotype.           (line  45)
* Phenotype.operator<<():                Phenotype.           (line  59)
* Phenotype.setFitness():                Phenotype.           (line  53)
* Phenotype.setValid():                  Phenotype.           (line  47)
* phenotype2Genotype(), GEGrammar:       GEGrammar.           (line  70)
* pointMutator():                        EXAMPLES/IntertwinedSpirals/GE_MITGALIB/GEListGenome.h.
                                                              (line  12)
* PointMutator():                        EXAMPLES/IntertwinedSpirals/GE_MITGALIB/main.cpp.
                                                              (line  34)
* pointMutator():                        EXAMPLES/CartCentering/GE_MITGALIB/GEListGenome.h.
                                                              (line  12)
* PointMutator():                        EXAMPLES/CartCentering/GE_MITGALIB/main.cpp.
                                                              (line  34)
* pointMutator():                        EXAMPLES/SantaFeAntTrail/GE_MITGALIB/GEListGenome.h.
                                                              (line  12)
* PointMutator():                        EXAMPLES/SantaFeAntTrail/GE_MITGALIB/main.cpp.
                                                              (line  23)
* print_individual() <1>:                EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-lua.cpp.
                                                              (line 104)
* print_individual() <2>:                EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-libtcc.cpp.
                                                              (line 115)
* print_individual() <3>:                EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-slang.cpp.
                                                              (line  76)
* print_individual() <4>:                EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-gcc.cpp.
                                                              (line  86)
* print_individual() <5>:                EXAMPLES/IntertwinedSpirals/GE_MITGALIB/main.cpp.
                                                              (line  75)
* print_individual() <6>:                EXAMPLES/CartCentering/GE_MITGALIB/cartcenter-lua.cpp.
                                                              (line 107)
* print_individual() <7>:                EXAMPLES/CartCentering/GE_MITGALIB/cartcenter-libtcc.cpp.
                                                              (line 126)
* print_individual() <8>:                EXAMPLES/CartCentering/GE_MITGALIB/cartcenter-slang.cpp.
                                                              (line  79)
* print_individual() <9>:                EXAMPLES/CartCentering/GE_MITGALIB/cartcenter-gcc.cpp.
                                                              (line  86)
* print_individual() <10>:               EXAMPLES/CartCentering/GE_MITGALIB/main.cpp.
                                                              (line  96)
* print_individual() <11>:               EXAMPLES/SantaFeAntTrail/GE_MITGALIB/santafe-lua.cpp.
                                                              (line  38)
* print_individual() <12>:               EXAMPLES/SantaFeAntTrail/GE_MITGALIB/santafe-tcc.cpp.
                                                              (line  34)
* print_individual() <13>:               EXAMPLES/SantaFeAntTrail/GE_MITGALIB/santafe-slang.cpp.
                                                              (line  34)
* print_individual() <14>:               EXAMPLES/SantaFeAntTrail/GE_MITGALIB/santafe-gcc.cpp.
                                                              (line  32)
* print_individual():                    EXAMPLES/SantaFeAntTrail/GE_MITGALIB/main.cpp.
                                                              (line  51)
* Production:                            Production.          (line   6)
* Production.clear():                    Production.          (line  38)
* Production.getMinimumDepth():          Production.          (line  47)
* Production.getRecursive():             Production.          (line  41)
* Production.operator<<():               Production.          (line  53)
* Production.setMinimumDepth():          Production.          (line  50)
* Production.setRecursive():             Production.          (line  44)
* readBNFFile(), CFGrammar:              CFGrammar.           (line  53)
* readBNFString(), CFGrammar:            CFGrammar.           (line  60)
* Rule:                                  Rule.                (line   6)
* Rule.clear():                          Rule.                (line  39)
* Rule.getMinimumDepth():                Rule.                (line  48)
* Rule.getRecursive():                   Rule.                (line  42)
* Rule.setMinimumDepth():                Rule.                (line  51)
* Rule.setRecursive():                   Rule.                (line  45)
* setCurrentLevel(), Tree:               Tree.                (line  57)
* setData(), Tree:                       Tree.                (line  62)
* setDepth(), Tree:                      Tree.                (line  52)
* setEffectiveSize() <1>:                EXAMPLES/IntertwinedSpirals/GE_MITGALIB/GEListGenome.h.
                                                              (line  12)
* setEffectiveSize() <2>:                EXAMPLES/CartCentering/GE_MITGALIB/GEListGenome.h.
                                                              (line  12)
* setEffectiveSize():                    EXAMPLES/SantaFeAntTrail/GE_MITGALIB/GEListGenome.h.
                                                              (line  12)
* setEffectiveSize(), Genotype:          Genotype.            (line  87)
* setFitness(), Genotype:                Genotype.            (line  75)
* setFitness(), Phenotype:               Phenotype.           (line  53)
* setFull(), GEGrammarSI:                GEGrammarSI.         (line  66)
* setGenotype(), Mapper:                 Mapper.              (line  56)
* setGenotypeMaxCodonValue(), Mapper:    Mapper.              (line  78)
* setGrow(), GEGrammarSI:                GEGrammarSI.         (line  60)
* setIndex(), Initialiser:               Initialiser.         (line  49)
* setMaxCodonValue(), Genotype:          Genotype.            (line  81)
* setMaxDepth(), GEGrammarSI:            GEGrammarSI.         (line  72)
* setMaxWraps(), GEGrammar:              GEGrammar.           (line  50)
* setMinimumDepth(), Production:         Production.          (line  50)
* setMinimumDepth(), Rule:               Rule.                (line  51)
* setPhenotype(), Mapper:                Mapper.              (line  73)
* setPopSize(), Initialiser:             Initialiser.         (line  43)
* setRecursive(), Production:            Production.          (line  44)
* setRecursive(), Rule:                  Rule.                (line  45)
* setStartSymbol(), Grammar:             Grammar.             (line  61)
* setTailRatio(), GEGrammarSI:           GEGrammarSI.         (line  78)
* setTailSize(), GEGrammarSI:            GEGrammarSI.         (line  85)
* setType(), Symbol:                     Symbol.              (line  46)
* setValid(), Genotype:                  Genotype.            (line  69)
* setValid(), Phenotype:                 Phenotype.           (line  47)
* setValid(), Tree:                      Tree.                (line  66)
* setValidGrammar(), Grammar:            Grammar.             (line  55)
* setWraps(), Genotype:                  Genotype.            (line  93)
* SLadd_intrinsic_variable() <1>:        EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-slang.h.
                                                              (line  58)
* SLadd_intrinsic_variable() <2>:        EXAMPLES/IntertwinedSpirals/GE_MITGALIB/SLangEndCode.
                                                              (line  16)
* SLadd_intrinsic_variable() <3>:        EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-slang.cpp.
                                                              (line  56)
* SLadd_intrinsic_variable() <4>:        EXAMPLES/CartCentering/GE_EO/eoGEEvalFunc-slang.h.
                                                              (line  32)
* SLadd_intrinsic_variable() <5>:        EXAMPLES/CartCentering/GE_MITGALIB/cartcenter-slang.cpp.
                                                              (line  32)
* SLadd_intrinsic_variable() <6>:        EXAMPLES/SantaFeAntTrail/GE_EO/eoGEEvalFuncSlang.h.
                                                              (line   6)
* SLadd_intrinsic_variable():            EXAMPLES/SantaFeAntTrail/GE_MITGALIB/santafe-slang.cpp.
                                                              (line  11)
* SLang_init_slang() <1>:                EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-slang.h.
                                                              (line  21)
* SLang_init_slang() <2>:                EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-slang.cpp.
                                                              (line  24)
* SLang_init_slang() <3>:                EXAMPLES/CartCentering/GE_EO/eoGEEvalFunc-slang.h.
                                                              (line  21)
* SLang_init_slang() <4>:                EXAMPLES/CartCentering/GE_MITGALIB/cartcenter-slang.cpp.
                                                              (line  24)
* SLang_init_slang() <5>:                EXAMPLES/SantaFeAntTrail/GE_EO/eoGEEvalFuncSlang.h.
                                                              (line   6)
* SLang_init_slang():                    EXAMPLES/SantaFeAntTrail/GE_MITGALIB/santafe-slang.cpp.
                                                              (line  11)
* SLang_init_slmath() <1>:               EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-slang.h.
                                                              (line  21)
* SLang_init_slmath() <2>:               EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-slang.cpp.
                                                              (line  24)
* SLang_init_slmath() <3>:               EXAMPLES/CartCentering/GE_EO/eoGEEvalFunc-slang.h.
                                                              (line  21)
* SLang_init_slmath():                   EXAMPLES/CartCentering/GE_MITGALIB/cartcenter-slang.cpp.
                                                              (line  24)
* SLang_init_stdio() <1>:                EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-slang.h.
                                                              (line  21)
* SLang_init_stdio() <2>:                EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-slang.cpp.
                                                              (line  24)
* SLang_init_stdio() <3>:                EXAMPLES/CartCentering/GE_EO/eoGEEvalFunc-slang.h.
                                                              (line  21)
* SLang_init_stdio():                    EXAMPLES/CartCentering/GE_MITGALIB/cartcenter-slang.cpp.
                                                              (line  24)
* SLang_load_file() <1>:                 EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-slang.h.
                                                              (line  26)
* SLang_load_file() <2>:                 EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-slang.cpp.
                                                              (line  29)
* SLang_load_file() <3>:                 EXAMPLES/CartCentering/GE_EO/eoGEEvalFunc-slang.h.
                                                              (line  26)
* SLang_load_file() <4>:                 EXAMPLES/CartCentering/GE_MITGALIB/cartcenter-slang.cpp.
                                                              (line  29)
* SLang_load_file() <5>:                 EXAMPLES/SantaFeAntTrail/GE_EO/eoGEEvalFuncSlang.h.
                                                              (line   6)
* SLang_load_file():                     EXAMPLES/SantaFeAntTrail/GE_MITGALIB/santafe-slang.cpp.
                                                              (line  11)
* SLang_load_string() <1>:               EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-slang.h.
                                                              (line  67)
* SLang_load_string() <2>:               EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-slang.cpp.
                                                              (line  65)
* SLang_load_string() <3>:               EXAMPLES/CartCentering/GE_EO/eoGEEvalFunc-slang.h.
                                                              (line  66)
* SLang_load_string() <4>:               EXAMPLES/CartCentering/GE_MITGALIB/cartcenter-slang.cpp.
                                                              (line  62)
* SLang_load_string() <5>:               EXAMPLES/SantaFeAntTrail/GE_EO/eoGEEvalFuncSlang.h.
                                                              (line   6)
* SLang_load_string():                   EXAMPLES/SantaFeAntTrail/GE_MITGALIB/santafe-slang.cpp.
                                                              (line  11)
* Symbol:                                Symbol.              (line   6)
* Symbol.getType():                      Symbol.              (line  43)
* Symbol.operator=():                    Symbol.              (line  49)
* Symbol.operator==():                   Symbol.              (line  51)
* Symbol.setType():                      Symbol.              (line  46)
* tcc_add_file() <1>:                    EXAMPLES/SantaFeAntTrail/GE_EO/eoGEEvalFuncTCC.h.
                                                              (line  15)
* tcc_add_file():                        EXAMPLES/SantaFeAntTrail/GE_MITGALIB/santafe-tcc.cpp.
                                                              (line  18)
* tcc_add_library() <1>:                 EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-libtcc.h.
                                                              (line  53)
* tcc_add_library() <2>:                 EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-libtcc.cpp.
                                                              (line  50)
* tcc_add_library() <3>:                 EXAMPLES/CartCentering/GE_EO/eoGEEvalFunc-libtcc.h.
                                                              (line  55)
* tcc_add_library():                     EXAMPLES/CartCentering/GE_MITGALIB/cartcenter-libtcc.cpp.
                                                              (line  60)
* tcc_compile_string() <1>:              EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-libtcc.h.
                                                              (line  61)
* tcc_compile_string() <2>:              EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-libtcc.cpp.
                                                              (line  58)
* tcc_compile_string() <3>:              EXAMPLES/CartCentering/GE_EO/eoGEEvalFunc-libtcc.h.
                                                              (line  63)
* tcc_compile_string() <4>:              EXAMPLES/CartCentering/GE_MITGALIB/cartcenter-libtcc.cpp.
                                                              (line  68)
* tcc_compile_string() <5>:              EXAMPLES/SantaFeAntTrail/GE_EO/eoGEEvalFuncTCC.h.
                                                              (line  15)
* tcc_compile_string():                  EXAMPLES/SantaFeAntTrail/GE_MITGALIB/santafe-tcc.cpp.
                                                              (line  18)
* tcc_delete() <1>:                      EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-libtcc.h.
                                                              (line  95)
* tcc_delete() <2>:                      EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-libtcc.cpp.
                                                              (line  92)
* tcc_delete() <3>:                      EXAMPLES/CartCentering/GE_EO/eoGEEvalFunc-libtcc.h.
                                                              (line  97)
* tcc_delete():                          EXAMPLES/CartCentering/GE_MITGALIB/cartcenter-libtcc.cpp.
                                                              (line 102)
* tcc_get_symbol() <1>:                  EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-libtcc.h.
                                                              (line  81)
* tcc_get_symbol() <2>:                  EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-libtcc.cpp.
                                                              (line  78)
* tcc_get_symbol() <3>:                  EXAMPLES/CartCentering/GE_EO/eoGEEvalFunc-libtcc.h.
                                                              (line  83)
* tcc_get_symbol():                      EXAMPLES/CartCentering/GE_MITGALIB/cartcenter-libtcc.cpp.
                                                              (line  88)
* tcc_new() <1>:                         EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-libtcc.h.
                                                              (line  53)
* tcc_new() <2>:                         EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-libtcc.cpp.
                                                              (line  50)
* tcc_new() <3>:                         EXAMPLES/CartCentering/GE_EO/eoGEEvalFunc-libtcc.h.
                                                              (line  55)
* tcc_new() <4>:                         EXAMPLES/CartCentering/GE_MITGALIB/cartcenter-libtcc.cpp.
                                                              (line  60)
* tcc_new() <5>:                         EXAMPLES/SantaFeAntTrail/GE_EO/eoGEEvalFuncTCC.h.
                                                              (line  15)
* tcc_new():                             EXAMPLES/SantaFeAntTrail/GE_MITGALIB/santafe-tcc.cpp.
                                                              (line  18)
* tcc_relocate() <1>:                    EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-libtcc.h.
                                                              (line  61)
* tcc_relocate() <2>:                    EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-libtcc.cpp.
                                                              (line  78)
* tcc_relocate() <3>:                    EXAMPLES/CartCentering/GE_EO/eoGEEvalFunc-libtcc.h.
                                                              (line  63)
* tcc_relocate():                        EXAMPLES/CartCentering/GE_MITGALIB/cartcenter-libtcc.cpp.
                                                              (line  88)
* tcc_run() <1>:                         EXAMPLES/SantaFeAntTrail/GE_EO/eoGEEvalFuncTCC.h.
                                                              (line  15)
* tcc_run():                             EXAMPLES/SantaFeAntTrail/GE_MITGALIB/santafe-tcc.cpp.
                                                              (line  18)
* tcc_set_output_type() <1>:             EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-libtcc.h.
                                                              (line  53)
* tcc_set_output_type() <2>:             EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-libtcc.cpp.
                                                              (line  50)
* tcc_set_output_type() <3>:             EXAMPLES/CartCentering/GE_EO/eoGEEvalFunc-libtcc.h.
                                                              (line  55)
* tcc_set_output_type() <4>:             EXAMPLES/CartCentering/GE_MITGALIB/cartcenter-libtcc.cpp.
                                                              (line  60)
* tcc_set_output_type() <5>:             EXAMPLES/SantaFeAntTrail/GE_EO/eoGEEvalFuncTCC.h.
                                                              (line  15)
* tcc_set_output_type():                 EXAMPLES/SantaFeAntTrail/GE_MITGALIB/santafe-tcc.cpp.
                                                              (line  18)
* Tree:                                  Tree.                (line   6)
* Tree.clear():                          Tree.                (line  68)
* Tree.getCurrentLevel():                Tree.                (line  55)
* Tree.getData():                        Tree.                (line  60)
* Tree.getDepth():                       Tree.                (line  49)
* Tree.getValid():                       Tree.                (line  64)
* Tree.setCurrentLevel():                Tree.                (line  57)
* Tree.setData():                        Tree.                (line  62)
* Tree.setDepth():                       Tree.                (line  52)
* Tree.setValid():                       Tree.                (line  66)
* updateRuleFields(), CFGrammar:         CFGrammar.           (line  90)


