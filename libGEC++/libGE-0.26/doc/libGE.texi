\input texinfo @c -*-texinfo-*-
@c %**start of header
@setfilename libGE.info
@include version.texi
@settitle libGE @value{VERSION}
@setchapternewpage odd
@c %**end of header

@copying
This manual is for libGE, version @value{VERSION}, a C++ library that
implements the Grammatical Evolution mapping process.

Copyright @copyright{} 2003-2006 Biocomputing-Developmental Systems Centre,
University of Limerick, Ireland.
Permission is granted to copy, distribute and/or modify this document under the
terms of the GNU Free Documentation License, Version 1.2 or any later versions
published by the Free Software Foundation; with no Invariant Sections, no
Front-Cover Texts, and no Back-Cover Texts. A copy of the license is included
in the section entitled ``GNU Free Documentation License''.
@end copying

@titlepage
@title libGE
@subtitle Grammatical Evolution Library
@subtitle for version @value{VERSION}, @value{UPDATED}
@author Miguel Nicolau
@author Darwin Slattery
@c Copyright page
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@contents

@ifnottex
@node Top,Overview
@top libGE
@insertcopying
@end ifnottex
@menu
* Overview::			Purpose of libGE and installation instructions.
* Introduction to libGE::	Introduction to libGE.
* Programming Interface::	The programming interface of libGE.
* Grammars::			Writing grammars to use with libGE.
* Search Engines::		Search Engines tested with libGE.
* Evaluators::			Evaluators tested with libGE.
* Examples::			Examples of usage of libGE.
* FAQ::				Frequently Asked Questions.
* Copying This Manual::		License for copying this manual.
* References::			Bibliographic references.
* Index::			Complete index.
@end menu

@c =================================================================== Overview
@node Overview,Introduction to libGE,Top,Top
@chapter Overview
@cindex Overview

@menu
* Purpose::			Purpose of libGE.
* Installation::		Installation instructions.
@end menu

@c --- Purpose ---
@node Purpose,Installation,,Overview
@section Purpose
@include intro.texi

@c --- Installation ---
@node Installation,,Purpose,Overview
@section Installation
@include install.texi

@c ======================================================= Introduction to libGE
@node Introduction to libGE,Programming Interface,Overview,Top
@chapter Introduction to libGE

@menu
* Grammatical Evolution::	Introduction to GE.
* Using libGE::			Concepts for developing code with libGE.
@end menu

@c --- Grammatical Evolution ---
@node Grammatical Evolution,Using libGE,,Introduction to libGE
@section Grammatical Evolution
@cindex Grammatical Evolution
@cindex GE
@cindex BNF

@menu
* Example of Mapping Process::	Example of Mapping Process.
@end menu

Grammatical Evolution (@cite{O'Neill and Ryan, 2003}) (GE) is an evolutionary
algorithm approach to automatic program generation, which evolves strings of
binary values, and uses a grammar in BNF (Backus-Naur Form) notation to map
those strings into programs, which can then be evaluated. The modular design
behind GE means that any search algorithm can be used to evolve a population
of binary strings, and after mapping each individual onto a program using
GE, any program/algorithm can be used to evaluate those individuals.

The life-cycle of a Grammatical Evolution run is as follows: a chosen
@dfn{Search Engine} (typically a variable-length genetic algorithm) creates a
population of individuals. Each of these strings represents a potential solution
for the problem to be solved, and therefore needs to be evaluated so that a
fitness score can be attributed to each (that is, how well does the program that
each string represents fairs on the current problem). To that end, these strings
will be mapped onto programs by GE, through the use of a
@dfn{Language Specification} (typically a BNF grammar). The resulting programs
can then be evaluated through a @dfn{Problem Specification} (for example, an
interpreter/compiler), which will attribute each program a fitness score. These
scores can then be sent back to the search engine, which will use then to
evolve a new population of individuals, which will also need to be evaluated.

This cycle goes on until a predefined stop condition is met (usually if a
solution is found, or if a maximum number of evaluations has been reached).

@sp 1
@image{ge,7cm,,Overview of the system}

This process is based on the idea of a @dfn{Genotype} to @dfn{Phenotype}
mapping: an individual comprised of binary values (genotype) is evolved, and,
before being evaluated, is subjected to a mapping process to create a program
(phenotype), which is then evaluated by a fitness function. This creates two
distinct spaces, a search space and a solution space. The following figure
shows the mapping process employed in GE, and its biological equivalent.

@sp 1
@cindex Genotype to Phenotype mapping
@image{g2p-ge,7cm,,Genotype to Phenotype Mapping}


@cindex BNF
Typically, the language specification is done through a BNF context-free
grammar. A BNF grammar is represented by a tuple @math{\{N,T,P,S\}}, where
@math{T} is a set of @dfn{Terminal} symbols, i.e., items that can appear in
legal sentences of the grammar, and @math{N} is a set of @dfn{Non-Terminal}
symbols, which are temporary items used in the generation of terminals. @math{P}
is a set of @dfn{Productions} that map the non-terminal symbols to a
sequence of terminal (or non-terminal) symbols, and @math{S} is a
@dfn{Start Symbol}, from which all legal sentences must be generated.

The following is an example of a BNF grammar:

@cindex Grammar examples
@iftex
@vskip 10pt
@end iftex
@code{<Expr> ::= <Item> | <Expr> <Oper> <Item>}

@code{<Item> ::= 1.0 | x}

@code{<Oper> ::= + | - | * | /}
@iftex
@vskip 10pt
@end iftex

This grammar can be used by GE to evolve mathematical expressions. The symbols
surrounded by angled brackets (@code{<Expr>}, @code{<Oper>}, @code{<Item>}) are
non-terminal symbols, whereas all other symbols (@code{1.0}, @code{x}, @code{+},
@code{-}, @code{*}, @code{/}) are terminal symbols. The @code{::=} symbol
represents the separator for a production rule. In a context-free grammar, using
BNF notation, a production rule is specified as a non-terminal symbol (to the
left of the @code{::=} separator), and a series of possible transformations, to
the right of the @code{::=} symbol, and separated by a @code{|} symbol (which
should be read as ``or'').

The first non-terminal symbol to be defined is called the start symbol. In this
case, the start symbol is @code{<Expr>}.

@c --- Example of Mapping Process ---
@node Example of Mapping Process,,,Grammatical Evolution
@subsection Example of Mapping Process
@cindex Mapping process

The following figure shows an example string mapping in GE. Starting with
the variable length binary string shown, the first step is to interpret that
binary string as an integer string (the @dfn{Transcription} process); as a
default, GE uses 8 bits to encode each integer.

@sp 1
@image{ge-ex,10cm,,GE example}

The process of @dfn{Translation} can then begin; each integer is used to
choose rules from a BNF grammar. The grammar used in the example consists of
two rules with two productions and five productions, respectively, with its
start symbol being the @code{<Seq>} symbol. The first integer is therefore
used to choose a production from the @code{<Seq>} rule; this is done by
@math{modding} (i.e. calculating the remainder of the division) the value
@math{43} by @math{2}, which gives the value @math{1}, and therefore
choosing the second production, which transforms the non-terminal symbol
@code{<Seq>} into the sequence @code{<Seq> <vowel>}.

As the mapping process continues, the first non-terminal symbol of the mapping
expression is used to decide which rule to use. In this case, the @code{<Seq>}
symbol is still the first symbol on the mapping expression, so the next
integer from the integer string, @math{118}, is used to choose a production.
Using the same method as before, @math{118} is @math{modded} by @math{2},
giving the value @math{0}, which chooses the first production; the
@code{<Seq>} symbol is therefore replaced with @code{<vowel>}, and the
mapping expression becomes @code{<vowel> <vowel>}.

@cindex Wrapping
This process continues until there are no non-terminal symbols left in the
mapping expression. If the end of the integer string is reached and there are
still non-terminal symbols left in the mapping expression, the integer string
is re-read from the start, to attempt to fully map the individual, in a process
known as @dfn{Wrapping}. If, after a chosen upper limit of wrapping events, the
individual is still not mapped, then the mapping process is said to fail, and
the individual which generated the integer string is punished accordingly.

@c --- Using libGE ---
@node Using libGE,,Grammatical Evolution,Introduction to libGE
@section Using libGE

@menu
* The Mapping Process::		The mapping process part of libGE.
* The System Boundary::		The system boundary part of libGE.
@end menu

libGE is based on the idea of @dfn{Mappers}, that implement the translation
process. The concept of a mapper is best understood through the following
diagram:

@sp 1
@image{packages,10cm,,System packages}

As mentioned before, the search engine can be any algorithm that evolves
binary strings. The evaluator is usually a fitness function, that evaluates how
well a program solves the given problem (usually an interpreter or compiler,
when evolving computer programs). The @dfn{Mapping Process} and
@dfn{System Boundary} is where libGE works. Its objective is to transform
(i.e. map) a genotypic structure received from the search engine onto a program
recognisable by the evaluator.

@c --- The Mapping Process ---
@node The Mapping Process,The System Boundary,,Using libGE
@subsection The Mapping Process

The mapping process is where the data generated by the search engine is
transformed into a program for the evaluator, using an appropriate
grammar. To that purpose, a mapper is employed.

A @code{Mapper} is a data structure that transforms a @code{Genotype} structure
into a @code{Phenotype} structure, usually by employing a grammar. By setting
the @code{Genotype} of a mapper (using the @code{setGenotype()} method),
a @code{Phenotype} is automatically generated, through the use of a
@code{genotype2phenotype()} function, and can be retrieved from the
mapper through a call to the @code{getPhenotype()} method.

The easiest way to use libGE in your application is to maintain a global
@code{Mapper} object. This object should be initialised at the start of the
evolutionary run, if necessary (with actions such as loading a grammar, setting
a maximum number of wrapping events, etc).

When an individual from the search engine is ready for
evaluation, your fitness function passes a @code{Genotype} structure
corresponding to that individual (either created by libGE or by your own
application) to the @code{Mapper}; when this happens, the @code{Mapper} will
automatically update its @code{Phenotype} structure, which can then be retrieved
by your fitness function, which in turn can pass it on to the evaluator. Once
the evaluator has returned a fitness value, this value can finally be passed
back to your search engine.

The following is an example (in pseudo-code) of the way a mapper is employed.
Note that the program flow is controlled by the chosen search engine, and calls
are made to a mapper's methods both at the start of the run (for initialisation)
and each time an individual is ready for evaluation. Actions related to the use
of a mapper are marked by an asterisk (@code{*}).

@iftex
@vskip 10pt
@end iftex

@example
Create global mapper; *

Initialise mapper; *

Do evolutionary run

    Generate population of individuals;

    Evaluate each individual

        Transform individual to Genotype structure;

        Call Mapper.setGenotype(individual); *

        Call Mapper.getPhenotype(); *

        Pass Phenotype structure to evaluator;

        Collect fitness score from evaluator;

        Pass fitness back to search engine;

    Done

Done
@end example

@iftex
@vskip 10pt
@end iftex

@c --- The System Boundary ---
@node The System Boundary,,The Mapping Process,Using libGE
@subsection The System Boundary

This is where the different data structures, used in the search engine,
mapping process, and evaluator, are interfaced. To this end, libGE provides
a variety of methods which ease the transformation of any search engine's
data structures onto libGE @code{Genotype} structures. Similarly, there are
several forms in which the resulting @code{Phenotype} structure can be
retrieved, to ease the integration into the required evaluator.

There is also some (limited) support for data structures native to specific
search engines (@pxref{Search Engines}), which can be configured when libGE is
installed (@pxref{Installation}). When using those search engines which are
directly supported, the instruction @code{Transform individual to Genotype
structure} seen in the previous pseudo-code example will not be needed, as the
@code{Mapper.setGenotype()} method will accept the genome structures used in
those search engines.

There is also some limited support for search engines written in other
languages; @pxref{Search Engines}.

@c ======================================================= Programming Interface
@node Programming Interface,Grammars,Introduction to libGE,Top
@chapter Programming Interface
@cindex Interface
@cindex Programming Interface

@menu
* Class Hierarchy::	UML diagram of classes, composition, aggregation and derivation.
* Description::		Basic explanation of each class and its relationship with other classes.
* Interfaces::		Description and explanation of the programming interfaces.
* Designing your Own Mappers::		How to design your own mappers.
@end menu

@c --- Class Hierarchy ---
@node Class Hierarchy,Description,,Programming Interface
@section Class Hierarchy
@cindex Class hierarchy

The following diagram depicts the classes defined in libGE, along with their
main methods.

@sp 1
@image{allclasses,13cm,,Overview of the system}
@page

@c --- Description ---
@node Description,Interfaces,Class Hierarchy,Programming Interface
@section Description

The @code{Mapper} abstract class defines the basic structure of a mapper. It is
composed of one Genotype and one Phenotype objects, and defines the interface
for the (private) genotype to phenotype mapping methods
@code{genotype2phenotype} and @code{phenotype2genotype}. Every time a
@code{Genotype} structure is assigned to it, the @code{Phenotype} structure is
updated, and vice-versa.

The @code{Genotype} class defines a standard genotypic structure. It implements
the interface of the standard STL @code{vector} class
(@uref{http://www.sgi.com/tech/stl/}), defining a vector of @code{CodonType}
objects.

The @code{Phenotype} class defines a standard phenotypic structure. It
also implements the standard STL @code{vector} interface, defining
a vector of (pointers to) @code{Symbol} objects (note that a @code{Phenotype}
object is not responsible for the deletion of the @code{Symbol} objects in its
vector).

The @code{Grammar} abstract class derives from the @code{Mapper} class, and
adds several components and methods specific to implementing a grammar as a
mapper. It too implements the STL @code{vector} interface, defining a vector of
@code{Rule} objects (which compose its grammar).

The @code{Rule} class defines the rule of a grammar, that is, a left-hand side
composed of one or more symbols, and the associated productions (the possible
transformations for that set of symbols). It too implements the @code{vector}
interface, defining a vector of @code{Production} objects. It is also
composed of one @code{vector} of (pointers to) @code{Symbol} objects, which
define its left-hand side, and of which it is responsible for deletion.

The @code{Production} class defines a possible transformation for a given
set of symbols (typically, the left-hand side of a rule). It also implements
the @code{vector} interface, defining a vector of (pointers to) @code{Symbol}
objects. From those, it is responsible for the deletion of @code{Symbol}
objects with @code{getType()==TSymbol} only.

The @code{Symbol} class defines a symbol from a given grammar, and implements
the STL @code{string} interface. It can be either a terminal symbol, with
@code{getType()==TSymbol}, or a non-terminal symbol, with
@code{getType()==NTSymbol}.

The @code{Tree} class implements the basic structure of a n-ary tree. It is
a templated class, allowing for the derivation of trees of different sorts of
objects.

The @code{CFGrammar} abstract class derives from the @code{Grammar} class, and
defines a context-free grammar as a mapper. It adds methods specific to this
kind of grammar, such as reading Backus-Naur Form text representations. It is
also composed of one @code{Tree} object, which implements the @code{Tree}
interface with (pointers to) @code{Symbol} objects, and which represents the
derivation tree of the mapping process; it is not responsible for the deletion
of the @code{Symbol} objects to which it points to.

The @code{GEGrammar} class is derived from the @code{CFGrammar} class, and
implements the standard Grammatical Evolution mapping process. It implements the
@code{genotype2phenotype()} and @code{phenotype2genotype()} methods, as well as
the handling of wrapping events.

The @code{Initialiser} abstract class defines the basic form of an
initialisation process. It defines the interface for the method @code{init()},
which called in sequence initialises all the elements of a population.

The @code{GEGrammarSI} class derives from the @code{GEGrammar} class, and
adds to it the implementation of the sensible initialisation process
for Grammatical Evolution (@cite{Ryan and Azad, 2003}), by deriving from the
@code{Initialiser} class. It initialises the @code{Mapper} structures
@code{Genotype} and @code{Phenotype} through calls to the @code{init} function.


@c --- Interfaces ---
@node Interfaces,Designing your Own Mappers,Description,Programming Interface
@section Interfaces

@menu
* Genotype::		Definitions and interfaces of the Genotype class.
* Phenotype::		Definitions and interfaces of the Phenotype class.
* Mapper::		Definitions and interfaces of the Mapper class.
* Rule::		Definitions and interfaces of the Rule class.
* Production::		Definitions and interfaces of the Production class.
* Symbol::		Definitions and interfaces of the Symbol class.
* Grammar::		Definitions and interfaces of the Grammar class.
* Tree::		Definitions and interfaces of the Tree class.
* CFGrammar::		Definitions and interfaces of the CFGrammar class.
* GEGrammar::		Definitions and interfaces of the GEGrammar class.
* Initialiser::		Definitions and interfaces of the Initialiser class.
* GEGrammarSI::		Definitions and interfaces of the GEGrammarSI class.
@end menu

These are the interfaces defined for each of the classes used in libGE.

@c --- Genotype ---
@node Genotype,Phenotype,,Interfaces
@subsection Genotype
@findex Genotype

This class represents the structure of a genotype, as employed by libGE
mappers. It is simply an array of elements, each element corresponding to an
allele of an individual. The structures used by search engines to represent
genotype strings must be converted to this representation, before they can
benefit from libGE's mapping process.

@sp 1
@image{genotype,,,Genotype class}

Member function description:

@itemize
@item @code{Genotype(const int *newArray, const unsigned int newLength,
const bool newValid, const FitnessType newFitness)}:
Default constructor. Creates a genotype structure of length newLength,
using the elements of newArray, and sets its valid field to newValid
and its fitness to newFitness. Non-specified arguments are given default
values, as specified in the function prototype.
@item @code{Genotype(const vector<CodonType> &newVector, const bool newValid,
const FitnessType newFitness)}:
Constructor. Creates a genotype structure using the elements of newVector, and
sets its valid field to newValid and its fitness to newFitness. Non-specified
arguments are given default values, as specified in the function prototype.
@item @code{Genotype(const CodonType maxCodonValue)}:
Constructor. Creates an empty genotype structure, and sets maxCodonValue
to the value specified as argument.
@item @code{Genotype(const Genotype &copy):vector<CodonType>(copy)}:
Copy constructor.
@item @code{~Genotype()}:
Destructor.
@item @code{bool getValid() const}:
@findex Genotype.getValid()
@findex getValid(), Genotype
Returns the current valid field.
@item @code{void setValid(const bool newValid)}:
@findex Genotype.setValid()
@findex setValid(), Genotype
Set a new value for the valid field.
@item @code{FitnessType getFitness() const}:
@findex Genotype.getFitness()
@findex getFitness(), Genotype
Returns the current fitness score.
@item @code{
void setFitness(const FitnessType newFitness)}:
@findex Genotype.setFitness()
@findex setFitness(), Genotype
Sets a new fitness score.
@item @code{
CodonType getMaxCodonValue() const}:
@findex Genotype.getMaxCodonValue()
@findex getMaxCodonValue(), Genotype
Returns the maximum containable value in a codon.
@item @code{
void setMaxCodonValue(const CodonType newMaxCodonValue)}:
@findex Genotype.setMaxCodonValue()
@findex setMaxCodonValue(), Genotype
Sets the maximum containable value in a codon.
@item @code{
unsigned int getEffectiveSize() const}:
@findex Genotype.getEffectiveSize()
@findex getEffectiveSize(), Genotype
Returns effective length of genotype.
@item @code{
void setEffectiveSize(const unsigned int newEffectiveSize)}:
@findex Genotype.setEffectiveSize()
@findex setEffectiveSize(), Genotype
Sets effective length of genotype.
@item @code{
unsigned int getWraps() const}:
@findex Genotype.getWraps()
@findex getWraps(), Genotype
Returns number of wrapping events.
@item @code{
void setWraps(const unsigned int newWraps)}:
@findex Genotype.setWraps()
@findex setWraps(), Genotype
Sets number of wrapping events.
@item @code{
ostream &operator<<(ostream &stream, const Genotype &g)}:
@findex Genotype.operator<<()
@findex operator<<(), Genotype
Pretty print the contents of the genotype string.
@end itemize
@page

@c --- Phenotype ---
@node Phenotype,Mapper,Genotype,Interfaces
@subsection Phenotype
@findex Phenotype

This class represents the structure of a phenotype, as employed by libGE
mappers. As in nearly all cases the output of the GE mapping process will be a
text generated through the use of a grammar, it made sense to implement this
structure as being an array of characters. This structure will most likely have
to be converted to the output required by the evaluator used to score phenotype
structures.

@sp 1
@image{phenotype,,,Phenotype class}

Member function description:

@itemize
@item @code{Phenotype(const bool newValid, const FitnessType newFitness)}:
Default constructor. Creates a phenotype structure, and sets its valid
field to newValid and its fitness to newFitness. Non-specified arguments are
given default values, as specified in the function prototype.
@item @code{Phenotype(const Phenotype &copy)}:
Copy constructor.
@item @code{~Phenotype()}:
Destructor.
@item @code{bool getValid() const}:
@findex Phenotype.getValid()
@findex getValid(), Phenotype
Returns the current valid field.
@item @code{void setValid(const bool newValid)}:
@findex Phenotype.setValid()
@findex setValid(), Phenotype
Sets a new value for the valid field.
@item @code{FitnessType getFitness() const}:
@findex Phenotype.getFitness()
@findex getFitness(), Phenotype
Returns the current fitness score.
@item @code{void setFitness(const FitnessType newFitness)}:
@findex Phenotype.setFitness()
@findex setFitness(), Phenotype
Sets a new fitness score.
@item @code{string getString() const}:
@findex Phenotype.getString()
@findex getString(), Phenotype
Returns string containing phenotype symbols.
@item @code{ostream &operator<<(ostream &stream, const Phenotype &ph)}:
@findex Phenotype.operator<<()
@findex operator<<(), Phenotype
Print the contents of the phenotype.
@end itemize
@page

@c --- Mapper ---
@node Mapper,Rule,Phenotype,Interfaces
@subsection Mapper
@findex Mapper

This is an abstract class that cannot be instantiated; it defines the most
basic characteristics and functionality of a mapper. It is always composed of
both a Genotype and Phenotype structures, and contains a (private)
genotype2phenotype method, that is called every time a new genotype is set, and
a (private) phenotype2genotype method, that is called every time a new
phenotype is set.

@sp 1
@image{mapper,,,Mapper class}

Member function description:

@itemize
@item @code{Mapper()}:
Default constructor.
@item @code{Mapper(const Genotype &newGenotype)}:
Constructor with Genotype structure; set Genotype to newGenotype.
@item @code{Mapper(const Phenotype &newPhenotype)}:
Constructor with Phenotype structure; set Phenotype to newPhenotype.
@item @code{Mapper(const Mapper& copy)}:
Copy constructor.
@item @code{~Mapper()}:
Destructor.
@item @code{Genotype const * getGenotype() const}:
@findex Mapper.getGenotype()
@findex getGenotype(), Mapper
Returns a pointer to the genotype structure of this mapper.
@item @code{void setGenotype(const Genotype &newGenotype)}:
@findex Mapper.setGenotype()
@findex setGenotype(), Mapper
Sets this mapper's genotype structure to be a copy of the argument genotype
structure, and calls the genotype2Phenotype private method.
@item @code{void setGenotype(const GA1DArrayGenome<T> &genome)}:
@findex Mapper.setGenotype()
@findex setGenotype(), Mapper
Sets this mapper's genotype structure to be a copy of the argument
GA1DArrayGenome structure, and calls the genotype2Phenotype private method.
@item @code{void setGenotype(const GAListGenome<T> &genome)}:
@findex Mapper.setGenotype()
@findex setGenotype(), Mapper
Sets this mapper's genotype structure to be a copy of the argument
GAListGenome structure, and calls the genotype2Phenotype private method.
@item @code{Phenotype const * getPhenotype() const}:
@findex Mapper.getPhenotype()
@findex getPhenotype(), Mapper
Returns a pointer to the phenotype structure of this mapper.
@item @code{void setPhenotype(const Phenotype &newPhenotype)}:
@findex Mapper.setPhenotype()
@findex setPhenotype(), Mapper
Sets this mapper's phenotype structure to be a copy of the argument
phenotype structure, and calls the phenotype2Genotype private method.
@item @code{void setGenotypeMaxCodonValue(const CodonType newMaxCodonValue)}:
@findex Mapper.setGenotypeMaxCodonValue()
@findex setGenotypeMaxCodonValue(), Mapper
Sets the maximum codon value of the genotype structure.
@end itemize
@page

@c --- Rule ---
@node Rule,Production,Mapper,Interfaces
@subsection Rule
@findex Rule

This class implements a rule of a grammar. It is used by classes such as
Grammar to specify grammars. It is composed of a left hand side, containing
Symbol elements, and a right hand side, containing Production elements.

@sp 1
@image{rule,,,Rule class}

Member function description:

@itemize
@item @code{Rule(const unsigned int newLength)}:
Creates a new rule with newLength elements.
@item @code{Rule(const Rule &copy)}:
Copy constructor.
@item @code{~Rule()}:
Destructor; call redefined operator clear().
@item @code{void clear()}:
@findex Rule.clear()
@findex clear(), Rule
Delete all productions, and all symbols stored in lhs.
@item @code{bool getRecursive() const}:
@findex Rule.getRecursive()
@findex getRecursive(), Rule
Return the recursive nature of this rule.
@item @code{void setRecursive(const bool newRecursive)}:
@findex Rule.setRecursive()
@findex setRecursive(), Rule
Update the recursive nature of this rule.
@item @code{unsigned int getMinimumDepth() const}:
@findex Rule.getMinimumDepth()
@findex getMinimumDepth(), Rule
Return the minimum mapping depth of this rule.
@item @code{void setMinimumDepth(const unsigned int newMinimumDepth)}:
@findex Rule.setMinimumDepth()
@findex setMinimumDepth(), Rule
Update the minimum mapping depth of this Rule.
@end itemize
@page

@c --- Production ---
@node Production,Symbol,Rule,Interfaces
@subsection Production
@findex Production

This class implements the production of a grammar. It is used by the Rule class
to specify the various productions which make up a rule.

@sp 1
@image{production,,,Production class}

Member function description:

@itemize
@item @code{Production(const unsigned int newLength)}:
Creates a new Production with newLength elements.
@item @code{Production(const Production &copy)}:
Copy constructor; copy all symbols.
@item @code{~Production()}:
Destructor; call redefined operator clear().
@item @code{void clear()}:
@findex Production.clear()
@findex clear(), Production
Delete all terminal symbols and all symbol references.
@item @code{bool getRecursive() const}:
@findex Production.getRecursive()
@findex getRecursive(), Production
Return the recursive nature of this production.
@item @code{void setRecursive(const bool newRecursive)}:
@findex Production.setRecursive()
@findex setRecursive(), Production
Update the recursive nature of this production.
@item @code{unsigned int getMinimumDepth() const}:
@findex Production.getMinimumDepth()
@findex getMinimumDepth(), Production
Return the minimum mapping depth of this production.
@item @code{void setMinimumDepth(const unsigned int newMinimumDepth)}:
@findex Production.setMinimumDepth()
@findex setMinimumDepth(), Production
Update the minimum mapping depth of this production.
@item @code{ostream &operator<<(ostream &stream, Production const &p)}:
@findex Production.operator<<()
@findex operator<<(), Production
Pretty print the contents of the production.
@end itemize
@page

@c --- Symbol ---
@node Symbol,Grammar,Production,Interfaces
@subsection Symbol
@findex Symbol

This class implements a symbol of a grammar, be it a non-terminal or terminal
symbol. It is used both by the Rule class, to specify its left side
non-terminal symbols, and by the Production class, to specify its terminal and
non-terminal symbols.

It is also used by the Phenotype class, to specify phenotypic symbols. It can
hold any data type, but all data types will be treated as text, so for example
no arithmetic operations are possible.

@sp 1
@image{symbol,,,Symbol class}

Member function description:

@itemize
@item @code{Symbol(const string newArray, SymbolType newType)}:
Create a new Symbol object as a copy of newArray and with type newType, if
specified; otherwise the default values specified in the function prototype
are used.
@item @code{Symbol(const Symbol &copy)}:
Copy constructor.
@item @code{~Symbol()}:
Destructor.
@item @code{SymbolType getType() const}:
@findex Symbol.getType()
@findex getType(), Symbol
Return the type of the symbol (NTSymbol or TSymbol).
@item @code{void setType(const SymbolType newType)}:
@findex Symbol.setType()
@findex setType(), Symbol
Set the type of the symbol.
@item @code{Symbol &operator=(const string newArray)}:
@findex Symbol.operator=()
@findex operator=(), Symbol
Copy newArray.
@item @code{bool operator==(const Symbol &newSymbol)}:
@findex Symbol.operator==()
@findex operator==(), Symbol
Symbol comparison operator.
@end itemize
@page

@c --- Grammar ---
@node Grammar,Tree,Symbol,Interfaces
@subsection Grammar
@findex Grammar

This is an abstract class that cannot be instantiated; it defines the basic
characteristics and functionality of a Grammar mapper. It is composed of a
vector of Rule objects, defining a grammar, and of fields defining the maximum
number of allowed wrapping events and the validity of the current grammar.

@sp 1
@image{grammar,,,Grammar class}

Member function description:

@itemize
@item @code{Grammar():Mapper()}:
Default constructor.
@item @code{Grammar(const Genotype &newGenotype)}:
Constructor setting the genotype structure of this mapper to newGenotype.
@item @code{Grammar(const Phenotype &newPhenotype)}:
Constructor setting the phenotype structure of this mapper to newPhenotype.
@item @code{Grammar(const Grammar& copy)}:
Copy constructor.
@item @code{~Grammar()}:
Destructor: delete all Productions first, and then all rules.
@item @code{bool getValidGrammar() const}:
@findex Grammar.getValidGrammar()
@findex getValidGrammar(), Grammar
Return the validity of the current grammar.
@item @code{void setValidGrammar(const bool newValidGrammar)}:
@findex Grammar.setValidGrammar()
@findex setValidGrammar(), Grammar
Set the validity of the grammar.
@item @code{const Symbol* getStartSymbol() const}:
@findex Grammar.getStartSymbol()
@findex getStartSymbol(), Grammar
Return pointer to current start symbol.
@item @code{bool setStartSymbol(const unsigned int)}:
@findex Grammar.setStartSymbol()
@findex setStartSymbol(), Grammar
Change start symbol by index on Vector of rules.
@item @code{bool setStartSymbol(const Symbol*)}:
@findex Grammar.setStartSymbol()
@findex setStartSymbol(), Grammar
Change start symbol by symbol pointer.
@item @code{bool setStartSymbol(const string&)}:
@findex Grammar.setStartSymbol()
@findex setStartSymbol(), Grammar
Change start symbol by string.
@item @code{const Rule* getStartRule() const}:
@findex Grammar.getStartRule()
@findex getStartRule(), Grammar
Return pointer to current start rule.
@end itemize
@page

@c --- Tree ---
@node Tree,CFGrammar,Grammar,Interfaces
@subsection Tree
@findex Tree

This is a templated class that implements an n-ary tree.

@sp 1
@image{tree,,,Tree class}

Member function description:

@itemize
@item @code{Tree(const unsigned int newDepth,const unsigned int newCurrentLevel)}:
Constructor; initialises depth and current level.
@item @code{Tree(const T &newData,const unsigned int newCurrentLevel,const unsigned int newDepth)}:
Constructor; initialises data to match arguments.
@item @code{Tree(const Tree<T> &copy)}:
Copy constructor.
@item @code{~Tree()}:
Destructor; clear all sub-trees.
@item @code{unsigned int getDepth() const}:
@findex Tree.getDepth()
@findex getDepth(), Tree
Return depth from this node until the deepest leaf.
@item @code{void setDepth(const unsigned int newDepth)}:
@findex Tree.setDepth()
@findex setDepth(), Tree
Set new depth of this node.
@item @code{unsigned int getCurrentLevel() const}:
@findex Tree.getCurrentLevel()
@findex getCurrentLevel(), Tree
Return level of this node.
@item @code{void setCurrentLevel(const unsigned int newCurrentLevel)}:
@findex Tree.setCurrentLevel()
@findex setCurrentLevel(), Tree
Set new current level of this node.
@item @code{const T getData() const}:
@findex Tree.getData()
@findex getData(), Tree
Return data stored in this node.
@item @code{void setData(const T &newData)}:
@findex Tree.setData()
@findex setData(), Tree
Set data to store in this node.
@item @code{bool getValid() const}:
@findex Tree.getValid()
@findex getValid(), Tree
Return validity of this node.
@item @code{void setValid(const bool newValid)}:
@findex Tree.setValid()
@findex setValid(), Tree
Set validity of this node.
@item @code{void clear()}:
@findex Tree.clear()
@findex clear(), Tree
Remove all elements of this tree.
@end itemize
@page

@c --- CFGrammar ---
@node CFGrammar,GEGrammar,Tree,Interfaces
@subsection CFGrammar
@findex CFGrammar

This class implements the methods associated with the manipulation of
context-free grammars. It implements input and output methods for this type of
grammar, along with manipulation and analysis methods.

@sp 1
@image{cfgrammar,,,CFGrammar class}

Member function description:

@itemize
@item @code{CFGrammar():Grammar()}:
Default constructor.
@item @code{CFGrammar(const Genotype &newGenotype)}:
Constructor setting the genotype structure of this mapper to newGenotype.
@item @code{CFGrammar(const Phenotype &newPhenotype)}:
Constructor setting the phenotype structure of this mapper to newPhenotype.
@item @code{CFGrammar(const CFGrammar& copy)}:
Copy Constructor.
@item @code{~CFGrammar()}:
Destructor.
@item @code{bool readBNFFile(const char *filename)}:
@findex CFGrammar.readBNFFile()
@findex readBNFFile(), CFGrammar
Opens the file whose name is passed as an argument, reads its contents onto
a character string, and calls readBNFString.
@item @code{bool readBNFFile(const string &filename)}:
@findex CFGrammar.readBNFFile()
@findex readBNFFile(), CFGrammar
Interface to the @code{readBNFFile(const char *)} method.
@item @code{bool readBNFString(const char *stream)}:
@findex CFGrammar.readBNFString()
@findex readBNFString(), CFGrammar
Reads in the BNF grammar specified by its argument text. Returns true if
loading of grammar was successful, false otherwise.
@item @code{bool readBNFString(const string &stream)}:
@findex CFGrammar.readBNFString()
@findex readBNFString(), CFGrammar
Interface to the @code{readBNFString(const char *)} method.
@item @code{bool addBNFString(const char *stream)}:
@findex CFGrammar.addBNFString()
@findex addBNFString(), CFGrammar
Reads in the BNF grammar-part specified by its argument text, and adds it to
the current grammar. Returns true if loading of new grammar part was
successful, false otherwise.
@item @code{bool addBNFString(const string &stream)}:
@findex CFGrammar.addBNFString()
@findex addBNFString(), CFGrammar
Interface to the @code{addBNFString(const char *)} method.
@item @code{void outputBNF(ostream& stream)}:
@findex CFGrammar.outputBNF()
@findex outputBNF(), CFGrammar
Pretty print the current BNF grammar.
@item @code{Rule* findRule(const Symbol &nonterminal)}:
@findex CFGrammar.findRule()
@findex findRule(), CFGrammar
Returns the address of the rule defining the argument non-terminal symbol,
if it exists; otherwise returns NULL.
@item @code{const DerivationTree* getDerivationTree()}:
@findex CFGrammar.getDerivationTree()
@findex getDerivationTree(), CFGrammar
Builds the the current derivation tree, and returns its address.
@item @code{bool isRecursive(vector<Symbol*> &visitedRules, Rule *currentRule)}:
@findex CFGrammar.isRecursive()
@findex isRecursive(), CFGrammar
Returns the calculated recursive nature of the Rule passed as argument,
and updates its minimum mapping depth (minimumDepth)
@item @code{void updateRuleFields()}:
@findex CFGrammar.updateRuleFields()
@findex updateRuleFields(), CFGrammar
Update recursive and minimumDepth fields for every Rule
and Production in grammar.
@item @code{void clearRuleFields()}:
@findex CFGrammar.clearRuleFields()
@findex clearRuleFields(), CFGrammar
Update recursive and minimumDepth fields for every Rule
and Production in grammar.
@end itemize
@page

@c --- GEGrammar ---
@node GEGrammar,Initialiser,CFGrammar,Interfaces
@subsection GEGrammar
@findex GEGrammar

This class implements the standard GE mapping process. It implements the
virtual methods genotype2phenotype and phenotype2genotype, and the standard GE
wrapping operator.

@sp 1
@image{gegrammar,,,GEGrammar class}

Member function description:

@itemize
@item @code{GEGrammar():CFGrammar()}:
Default constructor.
@item @code{GEGrammar(const Genotype &newGenotype)}:
Constructor setting the genotype structure of this mapper to newGenotype.
@item @code{GEGrammar(const Phenotype &newPhenotype)}:
Constructor setting the phenotype structure of this mapper to newPhenotype.
@item @code{GEGrammar(const GEGrammar& copy)}:
Copy Constructor.
@item @code{~GEGrammar()}:
Destructor.
@item @code{unsigned int getMaxWraps() const}:
@findex GEGrammar.getMaxWraps()
@findex getMaxWraps(), GEGrammar
Return number of maximum allowed wrapping events.
@item @code{void setMaxWraps(const unsigned int newMaxWraps)}:
@findex GEGrammar.setMaxWraps()
@findex setMaxWraps(), GEGrammar
Set the new number of maximum allowed wrapping events.
@item @code{const DerivationTree* getDerivationTree()}:
@findex GEGrammar.getDerivationTree()
@findex getDerivationTree(), GEGrammar
Builds the the current derivation tree, and returns its address; if derivation
tree is impossible to build, returns NULL.
@item @code{const vector<Production*>* getProductions()}:
@findex GEGrammar.getProductions()
@findex getProductions(), GEGrammar
Returns a vector of all productions used during the mapping process.
@item @code{void buildDTree(DerivationTree&, vector<Production*>::iterator&)}:
@findex GEGrammar.buildDTree()
@findex buildDTree(), GEGrammar
Builds the derivation tree, based on the productions vector. Arguments are
current tree node, and iterator on productions vector.
@item @code{bool genotype2Phenotype()}:
@findex GEGrammar.genotype2Phenotype()
@findex genotype2Phenotype(), GEGrammar
Updates the contents of the phenotype structure, based on the current genotype
and the current grammar, and according to the standard GE mapping process.
Returns true upon a successful mapping, and false otherwise, and also updates
the valid field of the phenotype.
@item @code{bool phenotype2Genotype()}:
@findex GEGrammar.phenotype2Genotype()
@findex phenotype2Genotype(), GEGrammar
Updates the contents of the genotype structure, based on the current phenotype
and the current grammar, and according to a mapping process corresponding to
the inverse of the standard GE mapping process. Returns true upon a successful
inverse mapping, and false otherwise.
@item @code{bool genotype2PhenotypeStep(stack<const Symbol*> &nonterminals, Genotype::iterator &genoIt)}:
@findex GEGrammar.genotype2PhenotypeStep()
@findex genotype2PhenotypeStep(), GEGrammar
Performs one step of the mapping process, that is, maps the next non-terminal
symbol on the nonterminals stack passed as argument, using the codon at the
position pointed by genoIt.
@end itemize
@page

@c --- Initialiser ---
@node Initialiser,GEGrammarSI,GEGrammar,Interfaces
@subsection Initialiser
@findex Initialiser

This is an abstract class that cannot be instantiated; it defines the most
basic characteristics and functionality of an initialiser. An initialiser
contains a population size and a population index. It defines the virtual
method init(), which applies the initialisation process.

@sp 1
@image{initialiser,,,Initialiser class}

Member function description:

@itemize
@item @code{Initialiser(const unsigned int newPopSize)}:
Default constructor. Create vector of random seeds.
@item @code{Initialiser(const Initialiser&)}:
Copy constructor.
@item @code{~Initialiser()}:
Destructor.
@item @code{unsigned int getPopSize() const}:
@findex Initialiser.getPopSize()
@findex getPopSize(), Initialiser
Returns current population size of initialiser.
@item @code{void setPopSize(const unsigned int newPopSize)}:
@findex Initialiser.setPopSize()
@findex setPopSize(), Initialiser
Sets population size of initialiser.
@item @code{unsigned int getIndex() const}:
@findex Initialiser.getIndex()
@findex getIndex(), Initialiser
Returns current index of initialiser.
@item @code{void setIndex(const unsigned int newSeedsPos)}:
@findex Initialiser.setIndex()
@findex setIndex(), Initialiser
Sets population index of initialiser.
@end itemize
@page

@c --- GEGrammarSI ---
@node GEGrammarSI,,Initialiser,Interfaces
@subsection GEGrammarSI
@findex GEGrammarSI

This class implements the standard GE ramped half-and-half initialisation
routine, also known as sensible initialisation. It implements the virtual
methods from the class Initialiser.

@sp 1
@image{gegrammarsi,,,GEGrammarSI class}

Member function description:

@itemize
@item @code{
GEGrammarSI::GEGrammarSI()}:
Default constructor.
@item @code{
GEGrammarSI::GEGrammarSI(const Genotype& newGenotype)}:
Constructor setting the genotype structure of this mapper to newGenotype.
@item @code{
GEGrammarSI::GEGrammarSI(const Phenotype& newPhenotype)}:
Constructor setting the phenotype structure of this mapper to newPhenotype.
@item @code{
GEGrammarSI::GEGrammarSI(const GEGrammarSI& copy)}:
Copy Constructor.
@item @code{
GEGrammarSI::~GEGrammarSI()}:
Destructor.
@item @code{
float GEGrammarSI::getGrow() const}:
@findex GEGrammarSI.getGrow()
@findex getGrow(), GEGrammarSI
Return the grow percentage set for this initialiser.
@item @code{
void GEGrammarSI::setGrow(const float newGrow)}:
@findex GEGrammarSI.setGrow()
@findex setGrow(), GEGrammarSI
Update the grow percentage for this initialiser.
@item @code{
float GEGrammarSI::getFull() const}:
@findex GEGrammarSI.getFull()
@findex getFull(), GEGrammarSI
Return the full percentage set for this initialiser.
@item @code{
void GEGrammarSI::setFull(const float newFull)}:
@findex GEGrammarSI.setFull()
@findex setFull(), GEGrammarSI
Update the full percentage for this initialiser.
@item @code{
unsigned int GEGrammarSI::getMaxDepth() const}:
@findex GEGrammarSI.getMaxDepth()
@findex getMaxDepth(), GEGrammarSI
Return the maxDepth parameter set for this initialiser.
@item @code{
void GEGrammarSI::setMaxDepth(const unsigned int newMaxDepth)}:
@findex GEGrammarSI.setMaxDepth()
@findex setMaxDepth(), GEGrammarSI
Update the maxDepth parameter for this initialiser.

@item @code{
float GEGrammarSI::getTailRatio() const}:
@findex GEGrammarSI.getTailRatio()
@findex getTailRatio(), GEGrammarSI
Return the tail size percentage set for this initialiser.
@item @code{
void GEGrammarSI::setTailRatio(const float newTailRatio)}:
@findex GEGrammarSI.setTailRatio()
@findex setTailRatio(), GEGrammarSI
Update the tail size percentage for this initialiser, and set tailSize to 0.
@item @code{
unsigned int GEGrammarSI::getTailSize() const}:
@findex GEGrammarSI.getTailSize()
@findex getTailSize(), GEGrammarSI
Return the tail size set for this initialiser.
@item @code{
void GEGrammarSI::setTailSize(const unsigned int newTailSize)}:
@findex GEGrammarSI.setTailSize()
@findex setTailSize(), GEGrammarSI
Update the tail size for this initialiser, and set tailRatio to 0.

@item @code{
bool GEGrammarSI::growTree(DerivationTree &tree,const bool &growMethod,const int &maximumDepth)}:
@findex GEGrammarSI.growTree()
@findex growTree(), GEGrammarSI
Grow the derivation tree according to the grow or full method, up to the
maximumDepth specified.
@item @code{
bool GEGrammarSI::init(const unsigned int index)}:
@findex GEGrammarSI.init()
@findex init(), GEGrammarSI
Initialise the Genotype and Phenotype structures, according to the sensible
initialisation technique for GE. If index is not set (or if it is set
to UINT_MAX), initialise the structures as part of a series of calls to
init(); if it is set, initialise the structures as being the index-th member
(out of popSize) of the population.
The next call to this routine will initialise the structures as being the
next individual of a population of popSize individuals. There is an
exception to this rule:
* If a specific index is set, then the structures are initialised as being
the index-th individual of a population of popSize, and the next call
to this routine will initialise the index-th+1 individual (unless a
specific index is set again).
@end itemize
@page

@c --- Designing your Own Mappers ---
@node Designing your Own Mappers,,Interfaces,Programming Interface
@section Designing Your Own Mappers

This section describes how to extend libGE's capabilities by defining your own
mappers. The best way to customise the behaviour of a mapper is to derive a new
class. Depending on the type of mapper to be developed, one of the existing
classes should be derived; for example, the @code{Mapper} class is the most
general (for any kind of mapping process), whereas the @code{Grammar} class
is the most adequate for mapping processes involving any kind of grammars, and
finally the @code{GEGrammar} class is the adequate choice for mapping processes
very similar to the standard Grammatical Evolution approach.

For example, to create a mapper that reads a BNF grammar but implements a
slightly different mapping process to that of standard GE, you should derive
your class from the @code{CFGrammar} class, as this class already implements a
method to read BNF grammars. Your class hierarchy would look something like
this:

@code{class MyMapper : public CFGrammar}

Supposing the structure to store a grammar suits your mapping process, the only
methods you will have to implement are the virtual methods from
@code{CFGrammar}, that is, the methods @code{getDerivationTree},
@code{genotype2Phenotype} and @code{phenotype2Genotype}. These would look like
this:

@code{const DerivationTree* MyMapper::getDerivationTree()@{ ... your code ...@}}

@code{bool MyMapper::genotype2Phenotype()@{ ... your code ...@}}

@code{bool MyMapper::phenotype2Genotype()@{ ... your code ...@}}


@c =================================================================== Grammars
@node Grammars,Search Engines,Programming Interface,Top
@chapter Grammars
@cindex Grammars

@menu
* Format of Grammars::		The way in which grammars are specified.
* Type of Grammars::		Different types of grammars.
* libGE Extensions::		Extensions to grammar design introduced by libGE.
* Examples of Grammars::	Examples of grammars to use with libGE.
@end menu

@cindex Backus-Naur Form
@cindex BNF
Grammatical Evolution is based mainly on context-free grammars, specified using
the Backus-Naur Form (BNF) format, and therefore the class structures used in
libGE are based around this principle. However, the library was designed keeping
in mind possible extensions to GE, and is therefore extensible to other grammar
types and formats.

@c --- Format ---
@node Format of Grammars,Type of Grammars,,Grammars
@section Format of Grammars

@cindex BNF
@cindex XML grammars
There are several formats in which a grammar can be specified. Traditionally,
the format of choice when specifying a grammar is BNF, and this is the format
of choice for libGE; although not the easiest to parse, it is easy to write
and understand by the user. All grammars should be written in ASCII format.

@cindex BNF
@subsection BNF Grammars

A BNF grammar is represented by a tuple @math{\{N,T,P,S\}}, where
@math{T} is a set of @dfn{Terminal} symbols, i.e., items that can appear in
legal sentences of the grammar, and @math{N} is a set of @dfn{Non-Terminal}
symbols, which are temporary items used in the generation of terminals. @math{P}
is a set of @dfn{Productions} that map the non-terminal symbols to a
sequence of terminal (or non-terminal) symbols, and @math{S} is a
@dfn{Start Symbol}, from which all legal sentences must be generated.

When describing the syntax of BNF grammars accepted by libGE, the following
definitions are used:

@itemize
@item a @code{Production} is a specific transformation associated with a
non-terminal symbol, and is a set of terminal and non-terminal symbols;
@item a @code{Rule} is the set of all productions associated with a
non-terminal symbol;
@item a @code{Grammar} is the set of all rules specified.

@image{exgrammar,15cm,,Grammar parts}

@end itemize

@subsubsection Rule
@cindex Rule

A rule consists of a non-terminal symbol (@code{<NTSymbol>}), followed by the
@code{::=} token, and by a sequence of one or more productions, separated by
the @code{|} token. Newlines can be used to separate productions, provided that
they occur only before the @code{|} tokens; newlines preceded by a @code{\}
character are ignored. Spaces are allowed (but not mandatory) before and after
each of the symbols @code{<NTSymbol>}, @code{::=} and @code{|}, and before and
after each production, acting as token separators. Rules must always be
specified in separate lines.

@subsubsection Production
@cindex Production

A production consists of a sequence of zero or more non-terminal
('@code{<NTSymbol>}') or terminal ('@code{TSymbol}') symbols. A sequence of one
or more spaces and/or tabular characters between symbols will result in a
single space character being placed in between those two symbols in sentences
generated with the grammar, while no space between symbols results in those
symbols following each other with no separator character, in generated
sentences (i.e. those symbols will be concatenated in the resulting
expression). Empty productions are accepted, as shown in the previous example.

@subsubsection Non-Terminal Symbols
@cindex Symbol

A non-terminal symbol is a sequence of one or more characters, enclosed within
angle brackets (@code{<...>}). Most ASCII characters are allowed, with the
exception of escape sequences.

@subsubsection Terminal Symbols

A terminal symbol is a sequence of one or more ASCII characters, with the
exception of the space and newline characters, and the characters '@code{<}',
'@code{>}', '@code{\}', '@code{"}' and '@code{|}' (unless they are preceded
by a '@code{\}' character).

A terminal symbol can also be a sequence of any ASCII characters enclosed
within quotes (@code{"..."}), with the exception of newline, and the character
'@code{"}' (unless they are preceded by a '@code{\}' character).

Additionally, all standard ASCII escape sequences are accepted (with the
exception of the @code{\xnnn} sequence), and are translated into their
corresponding characters on sentences generated using the grammar. So if your
evaluator needs the output @code{\n}, then use @code{\\n} in your grammar.

@cindex Start Symbol
@subsubsection Start Symbol

The start symbol, by default, is the first symbol defined in a grammar (in the
example provided, the @code{<NTSymbol1>} symbol). However, libGE provides
methods to specify which non-terminal symbol to use as a start symbol, when the
default behaviour is not what is intended (@pxref{Programming Interface}).

@subsection Extended BNF Grammars

Extended BNF grammars are not supported at the moment by libGE.

@subsection XML Grammars

Grammars in XML format are not supported at the moment by libGE.

@page
@c --- Type ---
@node Type of Grammars,libGE Extensions,Format of Grammars,Grammars
@section Type of Grammars

@subsection Context-Free Grammars

@cindex CFG
@cindex Context-Free Grammars
The original Grammatical Evolution system was designed to work with
@dfn{Context-Free Grammars} (CFG), that is, grammars in which the choice of a
production to map a specific non-terminal symbol is always the same throughout
the mapping process, regardless of the context in which that symbol appears, and
does not depend on external factors. In other words, a specific codon value from
the genotype string will always choose the same production for a specific
non-terminal symbol.

@subsubsection Errors In Context-Free Grammars

@itemize
@item Endless recursions. Endless recursions are caused by non-terminal symbols
	that recursively map onto themselves. Consider the following example:

	@code{<S> ::= <A> | <B>}

	@code{<A> ::= a}

	@code{<B> ::= <B> b}

	In this grammar, if the non-terminal symbol @code{<B>} is chosen, then
	a sequence of terminal symbols only will never be generated. In cases
	when that might happen, the mapping methods in libGE will signal that
	the resulting @code{Phenotype} structure is false.

@item Useless symbols. Useless symbols are non-terminal symbols which are
	present in the grammar, but are unreachable from the start symbol.
	Consider the following example:

	@code{<S> ::= a | b}

	@code{<A> ::= a}

	In this grammar, the non-terminal symbol @code{<A>} is never reached,
	as there is no way to reach it from a mapping string starting with the
	symbol @code{<S>}. These symbols are disregarded by libGE, and cause
	no errors to the mapping process.

@item Undefined symbols. Undefined symbols are non-terminal symbols which are
	present in one or more productions, but have no defining rule.
	Consider the following example:

	@code{<S> ::= <A> | <B>}

	@code{<A> ::= a}

	In this grammar, the non-terminal symbol @code{<B>} is undefined,
	because there is no rule defining what that symbol can be mapped to.
	In libGE, grammars containing undefined symbols are accepted, but
	whenever one of those symbols is encountered during the mapping process,
	it is included directly in the resulting @code{Phenotype} structure, and
	that structure is flagged as being false.

@end itemize

@subsubsection Regular Grammars

@cindex Regular Grammars
@dfn{Regular Grammars} are a subset of CFG, in which all productions are
composed of zero or one terminal symbols, followed by zero or one non-terminal
symbols. The following is an example of a regular grammar:

@example
<A> ::= a <B>
<B> ::= b
@end example

Regular grammars describe exactly all regular languages and are in that sense
equivalent with finite state automata and regular expressions. They can be
right regular grammars, as in the example above, or left regular grammars, as
in the example below:

@example
<A> ::= <B> a
<B> ::= b
@end example

As they are a subset of CFG, regular grammars are supported by libGE.

@subsubsection Closed Grammars

@cindex Closed Grammars
There is a specific type of CFG, often called a @dfn{Closed Grammar}. These are
grammars which contain only one non-terminal symbol, and therefore are composed
of one rule only. The following is an example of a closed grammar:

@example
<Expr> ::= <Expr> + x
         | <Expr> - x
         |  x
@end example

@subsection Context-Sensitive Grammars

Context-sensitive grammars are not supported at the moment by libGE.

@subsection Attribute Grammars

Attribute grammars are not supported at the moment by libGE.

@page
@c --- libGE Extensions ---
@node libGE Extensions,Examples of Grammars,Type of Grammars,Grammars
@section libGE Extensions

@cindex Grammar extensions

To improve user control over the mapping process, libGE introduces a set of
commands that can be incorporated into grammars. These take the form of special
non-terminal symbols, which encode specific instructions to libGE's mapping
process. Whenever one of these symbols is encountered during the mapping
process, the associated command/instruction is executed.

The case may arise when a user has specified non-terminal symbols in a grammar
which bear the same name as the extension symbols introduced by libGE. To deal
with such cases, the following policy is employed:

@itemize
@item If one of the extension symbols is present in the grammar, but does not
	have a defining rule, then the associated extension command/instruction
	is executed;
@item If one of the extension symbols is present in the grammar, and it has a
	defining rule, then the associated extension command/instruction is
	ignored, and the symbol is replaced with one of its productions, as per
	the standard mapping process.
@end itemize

@subsection <GECodonValue>

@cindex <GECodonValue>
@cindex GECodonValue
The @code{<GECodonValue>} symbol has been introduced to allow the user to insert
codon values directly from the genotype onto the resulting phenotype. Consider
the following grammar:
@example
<Expr> ::= <Expr> + <GECodonValue>
         | <Expr> - <GECodonValue>
         |  <GECodonValue>
@end example

This grammar will generate mathematical expressions that will add or subtract
integer values, which are extracted from the genotype structure. Note that every
time a @code{<GECodonValue>} symbol is replaced with a codon value, that codon
is considered "used", so the next step in the mapping process will use the
following codon.

The range of values generated by @code{<GECodonValue>} depends on the data type of the codon used. The values extracted can be restricted to specific ranges, by using the following notation:

@example
<GECodonValue[-low][+high]>
@end example

@noindent
where @code{-low} and @code{+high} are optional value boundaries. So for
example, @code{<GECodonValue-10>} will extract the current codon and restrict
it to be a value of @math{10} or higher, @code{<GECodonValue+20>} will restrict
the value to be of @math{20} or lower, and @code{<GECodonValue-10+20>} will
restrict it to be between @math{10} and @math{20} (inclusive).

@page
@c --- Examples ---
@node Examples of Grammars,,libGE Extensions,Grammars
@section Examples of Grammars

@cindex Grammar examples
@cindex BNF grammar, examples

@subsection Text examples

The following grammar defines a sequence of one or more vowels:

@example
<Seq>   ::= <Vowel> | <Seq> <Vowel>
<Vowel> ::= A | E | I | O | U
@end example

@noindent
The following grammar defines a useless but somewhat funny sentence:

@example
<Sentence>   ::= <Article> <Nounphrase> <Verb> <Article> <Nounphrase>
<Article>    ::= the | a
<Nounphrase> ::= <Noun> | <Adjectives> <Noun>
<Noun>       ::= cat | dog | mouse
<Adjectives> ::= <Adjective> | <Adjectives> <Adjective>
<Adjective>  ::= smiling | big | happy | fake
<Verb>       ::= ate | hit
@end example

@subsection Math examples

The following grammar defines a simple arithmetic expression, working with
integer constants, which are constructed by concatenation:

@example
<Expr> ::= <Int>
         | <Expr><Oper><Int>
<Int>  ::= <Int><Digit>
         | <Digit>
<Digit>::= 0|1|2|3|4|5|6|7|8|9
<Oper> ::= +
         | -
         | *
         | /
@end example

@noindent
The following closed grammar defines a mathematical expression, working with
several operators, in which integer constants are created by extracting codons
from the genotype string:

@example
<Expr> ::= (<Expr>)
         | sin(<Expr>)
         | cos(<Expr>)
         | <Expr>+<GECodonValue>
         | <Expr>-<GECodonValue>
         | <Expr>*<GECodonValue>
         | <Expr>/<GECodonValue>
         | <GECodonValue>
         | (-<GECodonValue>)
@end example

@page
@subsection Code examples

The following grammar defines a C function that returns a mathematical
expression:

@example
<Fn> ::= double function(double x)\n@{\
         \t return <Expr>;\n\
         @}\n
<Expr> ::= <Item>
         | <Expr><Oper><Item>
<Item> ::= 1.0
         | x
<Oper> ::= +
         | -
         | *
         | /
@end example

@noindent
The following grammar defines a ready-to-compile C++ program, which returns
the number of tries a user needed to guess a constant, evolved with
number concatenation:

@example
<Prog>::="#include<iostream>\n\nusing namespace std;\n\n"<MainFunction>
<MainFunction>::="int main()@{\n"<MainVars>
<MainVars> ::= "int guess,tries=0,value="<Value>";\n"<MainLoop>
<Value> ::= <Value><Digit> | <Digit>
<Digit> ::= 0|1|2|3|4|5|6|7|8|9
<MainLoop> ::= "do@{\n\tcin >> guess;\n\
        if(guess>value)\n\
                cout << \"Lower.\\n\";\n\
        else if(guess<value)\n\
                cout << \"Higher.\\n\";\n\
        tries++;\n\
@}while(guess!=value);\n"<EndCode>
<EndCode> ::= "cout << \"Guessed in \" << tries << \" tries.\\n\";\n\
return tries;\n@}\n"

@end example

@c --- GE_ILLIGALSGA ---
@c @node GE_ILLIGALSGA,GE_MITGALIB,,Wrappers
@c 
@c @include GE_ILLIGALSGA.texi
@c 
@c @subsection Class Hierarchy
@c @indent
@c None.
@c 
@c @subsection Type Definitions and Structures
@c @indent
@c @code{#define BITS_PER_BYTE 8}
@c 
@c @code{#define UINTSIZE (BITS_PER_BYTE*sizeof(unsigned))}
@c 
@c @code{struct individual@{}
@c 
@c @code{    unsigned *chrom;}
@c 
@c @code{    double fitness;}
@c 
@c @code{	  int xsite;}
@c 
@c @code{	  int parent[2];}
@c 
@c @code{    int *utility;}
@c 
@c @code{@};}
@c 
@c @code{static GEGrammar mapper;}
@c 
@c @subsection Member Function List
@c @indent
@c @findex GE_ILLIGALSGA_getGenotype
@c @code{int GE_ILLIGALSGA_getGenotype(int **);}
@c 
@c @findex GE_ILLIGALSGA_getPhenotype
@c @code{int GE_ILLIGALSGA_getPhenotype(char **);}
@c 
@c @findex GE_ILLIGALSGA_validPhenotype
@c @code{int GE_ILLIGALSGA_validPhenotype();}
@c 
@c @findex GE_ILLIGALSGA_setMaxWraps
@c @code{void GE_ILLIGALSGA_setMaxWraps(int);}
@c 
@c @findex GE_ILLIGALSGA_readBNFFile
@c @code{int GE_ILLIGALSGA_readBNFFile(char *);}
@c 
@c @findex GE_ILLIGALSGA_readBNFString
@c @code{int GE_ILLIGALSGA_readBNFString(char *);}
@c 
@c @findex GE_ILLIGALSGA_outputBNF
@c @code{void GE_ILLIGALSGA_outputBNF();}
@c 
@c @findex GE_ILLIGALSGA_Mapper
@c @code{void GE_ILLIGALSGA_Mapper(struct individual *critter, int lchrom, int bpg);}
@c 
@c @subsection Member Function Description
@c @itemize
@c @findex GE_ILLIGALSGA_getGenotype
@c @item @code{GE_ILLIGALSGA_getGenotype}: creates an array of integers equal to
@c the contents of the current genotype, and assigns its address to the argument
@c pointer; returns the number of elements of the array.
@c @findex GE_ILLIGALSGA_getPhenotype
@c @item @code{GE_ILLIGALSGA_getPhenotype}: creates an array of characters
@c equal to the contents of the current phenotype, and assigns its address to the
@c argument pointer; returns the number of characters of the array (Array will be
@c NULL terminated, so number of characters  = phenotype size + 1).
@c @findex GE_ILLIGALSGA_validPhenotype
@c @item @code{GE_ILLIGALSGA_validPhenotype}: returns the valid field of the
@c current phenotype structure.
@c @findex GE_ILLIGALSGA_setMaxWraps
@c @item @code{GE_ILLIGALSGA_setMaxWraps}: set the maximum number of wrapping
@c operations (@pxref{Example of Mapping Process}).
@c @findex GE_ILLIGALSGA_readBNFFile
@c @item @code{GE_ILLIGALSGA_readBNFFile}: open the file specified as argument, and
@c load its content as a BNF grammar for the wrapper. Returns @code{1} if
@c successful in reading the grammar, and @code{0} otherwise.
@c @findex GE_ILLIGALSGA_readBNFString
@c @item @code{GE_ILLIGALSGA_readBNFString}: load the BNF grammar string passed as
@c an argument. Returns @code{1} if successful in reading the grammar, and @code{0}
@c otherwise.
@c @findex GE_ILLIGALSGA_outputBNF
@c @item @code{GE_ILLIGALSGA_outputBNF}: interface to the @code{outputBNF} method
@c of the mapper.
@c @findex GE_ILLIGALSGA_Mapper
@c @item @code{GE_ILLIGALSGA_Mapper}: load the binary genotype structure passed as
@c argument, and using @samp{bpg} bits per gene, translate this structure onto a
@c genotype structure, which will be assigned to the mapper.
@c @end itemize

@c --- GE_MITGALIB ---
@c @node GE_MITGALIB,,GE_ILLIGALSGA,Wrappers
@c 
@c @include GE_MITGALIB.texi
@c 
@c @subsection Class Hierarchy
@c @indent
@c @code{bool GE_MITGALIB_AssignGenotype(Mapper&,GA1DArrayGenome<unsigned char>&);}
@c 
@c @code{bool GE_MITGALIB_AssignGenotype(Mapper&,GAListGenome<unsigned char>&);}
@c 
@c @subsection Type Definitions and Structures
@c @indent
@c None.
@c 
@c @subsection Member Function List
@c @indent
@c @findex GE_MITGALIB_assignGenotype
@c @code{int GE_ILLIGALSGA_getGenotype(int **);}
@c 
@c @subsection Member Function Description
@c @itemize
@c @findex GE_MITGALIB_assignGenotype
@c @item @code{GE_MITGALIB_AssignGenotype}: receives a Mapper and a GAGenome as
@c arguments, and sets the genotype of the mapper to be the translation of the
@c argument GAGenome.
@c @end itemize

@c ============================================================= Search Engines
@node Search Engines,Evaluators,Grammars,Top
@chapter Search Engines
@cindex Search Engines

@menu
* IlliGAL sga-c::			Using the IlliGAL sga-c code with libGE.
* GALib::				Using the GALib library with libGE.
* EO::					Using EO with libGE.
* Using your own Search Engine::	Using libGE with other search engines.
@end menu

In this chapter you will find a brief introduction to the search engines which
have so far been successfully tested with libGE. Most of these are C++ packages,
but some are written in other languages. You will also find a quick guide to
using your own search engine.

Note: check the FAQ section (@pxref{FAQ}) for possible incompatibilities
between these search engines and some evaluators.

@c --- IlliGAL sga-c ---
@node IlliGAL sga-c,GALib,,Search Engines
@section IlliGAL sga-c

@itemize
@item @uref{http://www-illigal.ge.uiuc.edu/index.php3}
@end itemize

The IlliGAL sga-c code is a C language port of the original simple GA code from
David Goldberg's book (@cite{Goldberg,1989}). It provides a few extensions to
the original code, and is well documented in a technical report
(@cite{Smith,1994}), which is included with the download package.

@subsection License

The sga-c code is licensed free of charge, and therefore with no warranty of
any kind.

@subsection Version

The version tested with libGE is v1.1.

@subsection Installation

Simply decompress the package; it will create an @file{sga-c} directory. It
should work on most C compilers simply by running @command{make}; on specific
architecture, you might need to change settings at the start of the
@file{sga.h} file. There is no system-wide installation available.

@subsection Main features

The code provides a fast and effective implementation of a fixed-length genetic
algorithm, albeit severely limited. It is intended to be a simple program for
first-time GA experimentation. Its main features are:

@itemize
@item Fast and memory efficient: uses bit-level representation of chromosomes,
and bitmask implementation of the crossover and mutation operators.
@item Provides roulette-wheel, stochastic remainder and tournament selection
routines.
@end itemize

@subsection Usage

The code accepts parameters either through an input file, or by @code{stdin}
input. If you want to use different selection routines (the default choice is
roulette-wheel), you will need to change the @file{Makefile}.

The fitness function is contained in a file called @file{app.c}. Most of the
functions in this file are explained in the example @file{app.c} file. The
function containing the problem specification is called @file{objfunc()}. It is
responsible for setting the fitness score of the @code{struct individual}
chromosome passed as argument.

@subsection Examples

Two examples are provided with the code, in files @file{app1.c} (which is a
copy of @file{app.c}) and @file{app2.c}. These are explained in the technical
report provided.

@subsection Documentation

As the package is quite minimalistic, it does not need an exhaustive
documentation. An explanation of each file and its functionality exists in the
technical report provided. No website or mailing-list exist for the project.

@subsection Using with libGE

As this package is written in C, a specific @i{wrapper} is needed to allow it
to work with libGE. The code for this wrapper is included in the files
@file{GE_ILLIGALSGA.h} and @file{GE_ILLIGALSGA.cpp}. It maintains a static
@code{GEGrammar} mapper in memory, and provides the following functionality:

@itemize
@item @code{int GE_ILLIGALSGA_getGenotype(int **)}: allocates memory for an
integer array, stores the current genotype in that array, and returns the
address of the allocated memory in the argument pointer, as well as its size as
the return value. The user is responsible for freeing the allocated memory.
@item @code{int GE_ILLIGALSGA_getPhenotype(char **)}: allocates memory for a
NULL-terminated character array, stores the current phenotype in that array,
and returns the address of the allocated memory in the argument pointer, as
well as its size as the return value. The user is responsible for freeing the
allocated memory.
@item @code{int GE_ILLIGALSGA_validPhenotype()}: returns the validity of the
phenotype contained in the static mapper.
@item @code{void GE_ILLIGALSGA_setMaxWraps(int)}: sets the number of allowed
wrapping events for the static mapper.
@item @code{int GE_ILLIGALSGA_readBNFFile(char *)}: interface to the
@code{readBNFFile(char *)} method in @code{CFGrammar}, for the static mapper.
@item @code{int GE_ILLIGALSGA_readBNFString(char *)}: interface to the
@code{readBNFString(char *)} method in @code{CFGrammar}, for the static mapper.
@item @code{int GE_ILLIGALSGA_outputBNF()}: interface to the
@code{outputBNF(ostream&)} method in @code{CFGrammar}, for the static mapper,
with @code{cout} as the output stream.
@item @code{int GE_ILLIGALSGA_translate(unsigned *, int, int *, int, int,
int)}: accepts an array of @code{unsigned}, representing an sga-c chromosome,
and translates it to an array of integers, using the specified number of bits
per gene, and limiting the integer values to the range specified.
@item @code{void GE_ILLIGALSGA_Mapper(struct individual *, int, int)}: accepts
an sga-c chromosome, transforms it into a libGE @code{Genotype} structure, and
assigns it to the static mapper.
@end itemize

Each example in the @file{EXAMPLES} directory contains files which are to be
copied into the @file{sga-c} directory, overwriting some of the existing
default files.

@page
@c --- GALib ---
@node GALib,EO,IlliGAL sga-c,Search Engines
@section GALib

@itemize
@item @uref{http://lancet.mit.edu/ga/}
@end itemize

The GALib is a C++ library of genetic algorithm components. It has been around
for a long time, and is a well established library. It includes tools for
implementing genetic algorithms using practically any representation and
genetic operators, including parallel computing extensions, and even graphical
extensions.

@subsection License

The GALib is distributed under a BDS-style license, which allows for the
redistribution and use (commercial or otherwise), in either source code or
binary form, provided that its copyright notice and disclaimer are included.

@subsection Version

The latest version tested with libGE is 2.4.6.

@subsection Installation

The GALib has been tested with many different architectures, and should be easy
to configure and install. After download, uncompress the package. Inside the
created directory there will be a @file{makevars} file, edit it to match your
system configuration. Then use the standard @command{make} and @command{make
install} commands (you might want to check the contents of the @file{Makefile}
as well).

Note: version 2.4.6, when installing, does not copy the file
@file{std_stream.h} to the destination headers directory (along with files like
@file{ga.h}, etc). This is a bug; you must do it yourself. You can find the
file in the @file{ga/} sub-directory, inside the directory created when you
first uncompressed the distribution package.

@subsection Main features

The code boots an array of different representations and genetic operators
ready to be used; it relies on templates to allow the implementation of these
representations with any data type. Major features are:

@itemize
@item Many different algorithms available: simple GA, steady state GA,
incremental GA, deme GA.
@item Many scaling and selection schemes: linear scaling, power law scaling,
etc (for scaling), and rank selection, roulette-wheel, tournament, etc (for
selection).
@item Many representations available: lists, trees, binary strings, arrays up
to three dimensions, etc.
@item Although it is quite exhaustive, the code is still remarkably fast and
easy to use.
@end itemize

@subsection Usage

The best way to learn how to use the GALib is to try out some of the examples
provided. The documentation has an overview section that might help to get
familiarised with the code. In its simplest form, a GALib source code consists
of a main function, where the type of GA is chosen (e.g. steady-state), its
parameters are set, and the evolution cycle is called, and a function
containing the problem to be solved. Once more control is required, the code
becomes slightly more complex, but is still quite easy to use and understand.

@subsection Examples

The GALib package provides 27 example files, covering all major aspects of the
code.

@subsection Documentation

The documentation is well structured and complete. It is available online at
the website, and also as a pdf document for download.

@subsection Using with libGE

Being a C++ library, compiling the GALib with libGE is quite trivial. The main
task at hand is to transform the genetic structure you are using into a libGE
@code{Genotype} object. To implement the standard GE mapping, you should choose
one of the linear variable-length structures available in GALib, specifically
@code{GA1DArrayGenome<T>} or @code{GAListGenome<T>}, with the type chosen being
an @code{int} or @code{unsigned int}. If you do choose to use one of these,
libGE has already incorporated support for them, so you can use a call to the
@code{setGenotype} from the @code{Mapper} class in libGE, to automatically
assign a GALib genome to a mapper. Otherwise, you will have to transform that
genome into a @code{Genotype} object, prior to assigning it to the mapper you
are using.

Here is some pseudo-code showing how to use GALib and libGE, when using
supported structures from the former:

@iftex
@vskip 10pt
@end iftex

@example
Objective function (GAGenome)

    Cast GAGenome into structure chosen (e.g. GAListGenome);

    Assign it to mapper used;

    Recover phenotype;

    If phenotype is valid, recover fitness;

    Return fitness value.

End of function
@end example

Some of the operators provided might not follow strictly the original GE
implementation. To see how to write operators in GALib for GE, check some of
the examples provided (@pxref{Examples}).

@page
@c --- EO ---
@node EO,Using your own Search Engine,GALib,Search Engines
@section EO

@itemize
@item @uref{http://eodev.sourceforge.net/}
@end itemize

The EO (Evolving Objects) library is an extremely complete evolutionary
computation library, written in C++. It relies heavily on templates, so that if
a specific kind of evolutionary computation technique isn't directly supported,
it should be easy to build it using the existing abstract or concrete classes.

@subsection License

The EO library is released under the GNU Lesser General Public License.

@subsection Version

The latest version tested with libGE is 0.9.4.

@subsection Installation

At the time of writing this, EO is not updated frequently, so the best choice
is to use the latest CVS version. Once the code has been downloaded, first use
the @command{./autogen.sh} script (which calls @command{./configure}) to
configure the installation; then just run @command{make} (and @command{make
install} if you wish a system-wide installation).

Note: you can't have a global installation of both EO and GALib, the reason
being that both libraries create a @file{libga.a} file. It is therefore
recommended that you install at least one of the libraries (possibly even both)
locally.

@subsection Main features

EO is probably one of the most complete evolutionary computation libraries
available. It is designed so that the implementation of practically any
evolutionary algorithm is possible, and at the same time the resulting
algorithm will be easy to use for the end user. Its main features are:
@itemize
@item Extremely complete code: literally hundreds of classes are available.
@item Fully customisable: heavy usage of templates means the code can be
adapted to suit practically all search algorithms.
@item Complete technical reference: usage of @command{doxygen} on all source
files results in a full (albeit rather unpersonalised) technical documentation.
@item Code more, compile less: EO takes quite a while to compile (mainly due to
its heavy usage of templates), but the features provided (including a powerful
command line parser for arguments, as well as the ability of saving partial
runs and restarting them later) require no recompilations for parameter tuning.
@end itemize

@subsection Usage

EO is not the easiest evolutionary package to use, probably because of being so
complete. If one chooses to use the template files available (check the
Tutorial, Lesson five), then the code can be quite easy to implement, but not
easily tunable. For a fully tunable, practically ready to use base code, the
best approach is to start with the code available in Lesson four of the
Tutorial and change it.

Using EO requires some good knowledge of templates in C++, as well as a good
general knowledge of evolutionary computation; even simple things like
implementing a standard GA solving a onemax problem can seem like a daunting
task at the start. Emphasis seems to have been put on simplicity for the end
user, and not the programmer; writing an algorithm with EO is a hard task, but
the end result is an extremely simple to use and tune algorithm for the end
user.

@subsection Examples

Not many examples are provided with EO. Probably the best source of examples is
the Tutorial, with its five lessons.

@subsection Documentation

There is a Tutorial available on-line and for download, which is the best way to
get familiarised with EO. Also, a reference document is provided, generated
automatically by @command{doxygen}, as well as some publications and
presentations available on the website.

@subsection Using with libGE

As EO does not have any in-built data structure (a variable-length string of
bits or integers) that directly satisfies the requirements for GE, a specific
genotype structure has to be implemented, as well as genetic operators to work
on that structure. Check some of the examples provided on how to do this
(@pxref{Examples}), as well as the EO tutorial.

Probably the best way to implement a GE genotype is to create a class that uses
a linear structure, such as a @code{vector}, and to derive that class from the
@code{EO<T>} class (mandatory when using EO). There are a few mandatory member
functions for this class, such as the @code{printOn()} and @code{readFrom()}
methods, which need to be implemented. Operators also need to be implemented on
their own separate classes (@pxref{Examples}).

After that, you only need to implement your evaluation function, again on a
class of its own (deriving from @code{eoEvalFunc<T>}). Use the required
initialisation procedures (such as reading a grammar, etc) on the constructor.
Then implement a @code{operator()}, called a @i{functor}, which implements the
actual fitness function: it requires the translation of your genome structure
into a libGE @code{Genotype} structure and assigning it to your mapper (using
the method @code{setGenotype()}), which will then provide a phenotype (through
the method @code{getPhenotype()}) to evaluate.

The actual mapper to use can be located in the main file, for example. Check
the examples provided for more information (@pxref{Examples}).

@page
@c --- Using your own Search Engine ---
@node Using your own Search Engine,,EO,Search Engines
@section Using your own Search Engine

If you do not use any of the search engines listed in this section, then libGE
has not been (officially) tested with that search engine as of yet. In that
case, all you have to provide is a way to transform the genotypic structures
used by the search engine onto @code{Genotype} structures from libGE. If using
the C++ language, you will find that one of the several constructors available
for the @code{Genotype} class might be suitable for that transformation.

As for the genetic operators, if you would like to implement a strict GE
implementation, you will might have to implement your own, to ensure that
bit-level mutation is used, and crossover at codon boundary.

@c ================================================================= Evaluators
@node Evaluators,Examples,Search Engines,Top
@chapter Evaluators
@cindex Evaluators

@menu
* GCC::				Using the Gnu C Compiler.
* S-Lang::			Using the S-Lang library.
* TinyCC::			Using the TinyCC compiler.
* Lua::				Using the Lua interpreter.
* Using your own Evaluator::	Using libGE with other Evaluators.
@end menu

A typical usage of libGE involves choosing a search engine and an appropriate
mapping process, and applying them to a problem of choice. In many cases, this
problem might be external to the algorithm; a typical example would be a real
world application, where an interface is required with a physical simulator, or
an actual piece of hardware executing the evolved code. This chapter
illustrates how to interface libGE with an external evaluator, and gives
examples of how to use the evaluators which have so far been successfully
tested with libGE.

@c --- GCC ---
@node GCC,S-Lang,,Evaluators
@section GCC

@itemize
@item @uref{http://gcc.gnu.org/}
@end itemize

When evolving code using Grammatical Evolution, an obvious choice is to use a
compiler to execute the evolved code, and capture back its fitness (that is,
the goodness of the evolved code). While using GCC (the GNU C Compiler) might
seem a bit of overkill, it might be the only solution at times. Also,
interfacing with GCC or with any other compiler is a similar process, so the
guidelines on how to use GCC as an evaluator can be easily generalised to other
compilers.

@subsection License

The GCC compiler is distributed under the GNU General Public License.

@subsection Version

The latest version tested with libGE is 4.0.2.

@subsection Installation

The GCC compiler follows the standard GNU installation process, so after
download, uncompress the package. Inside the created directory, run the
@command{./configure} script, followed by @command{make} and @command{make
install}.

@subsection Main features

The GCC compiler is full of features, far too many to mention. It is the
compiler of choice for practically all Linux distributions, and can also be
used under different operating systems, such as BDS variants, MacOS, Windows,
etc. In addition, it supports multiple languages, such as C, C++, Objective-C,
Assembler, Fortran, Ada and Treelang.

@subsection Usage

The simplest usage of the GCC compiler is to call it using the name of the file
containing the code to be compiled as argument: @code{gcc code.c}. A multitude
of switches are available (several hundred), to control code optimisation,
output executable name, include file and library locations, etc.

@subsection Examples

No examples as such are provided by GCC, although its test suite is available.

@subsection Documentation

The manual page provided is extremely complete, if somewhat hard to read. The
website also contains a FAQ list, as well as web pointers to GCC documentation
and tutorials. In addition, there are countless books and documents about GCC,
both available online and to buy.

@subsection Using with libGE

Whenever an individual is ready for evaluation, its evolved code must be
written to a file. This file might also need some header and footer code,
depending on the grammar used. For example, if the code evolved is simply a
mathematical expression, such as

@code{y=3*5+2*3*sin(5)}

then it will need to be surrounded by code which will make it a valid C program:

@code{#include<math.h>
int main()@{ return 3*5+2*3*sin(5);@}}

In order to capture the return value of the function, several options are
available. A simple approach is to write the value into a file, transforming
the code into:

@code{#include<stdio.h>}

@code{#include<math.h>}

@code{int main()@{ printf(%f\n",3*5+2*3*sin(5));@}}

The output of the program, once compiled, can then be captured into a file. A
system call would then be needed to compile and execute the code; so after
asserting the validity of the phenotype string, and writing all the C code
around it, it should be written to a file (e.g. "phenotype.c"), and a system
call must be made to compile it, and a second call to execute the program. For
example:

@code{system("gcc -pipe individual.c");}

@code{system("a.out > result");}

The first line compiles the code, using the GCC flag @command{-pipe} to speed
up somewhat the compilation process. The second line then executes the compiled
code, retrieving its output into a file called @file{result}; the objective
function can then read the contents of that file to receive the output of the
phenotype code. These two system calls can be merged into one:

@code{system("gcc -pipe individual.c; a.out > result");}

Note that system calls (and the compilation process) are very expensive
processes, and therefore the use of a compiler like GCC as an evaluator should
only be considered in cases where there is no viable alternative. However, in
certain cases, such as when using a generational replacement in a genetic
algorithm, GCC can be much faster, as all individuals can be written into one
single file and be compiled at the same time.

@page
@c --- S-Lang ---
@node S-Lang,TinyCC,GCC,Evaluators
@section S-Lang

@itemize
@item @uref{http://www.s-lang.org/}
@end itemize

S-Lang is a multi-platform programmer's library designed to allow a developer
to create robust multi-platform software. It provides facilities required by
interactive applications such as display/screen management, keyboard input,
keymaps, and so on. The most noteworthy feature of the library is the slang
interpreter, that may be easily embedded into a program to make it extensible.

@subsection License

The S-Lang library is distributed under the GNU General Public License.

@subsection Version

The latest version tested with libGE is 2.0.4.

@subsection Installation

The S-Lang library also follows the standard GNU installation process, so after
download, uncompress the package. Inside the created directory, run the
@command{./configure} script, followed by @command{make} and @command{make
install}.

@subsection Main features

The S-Lang is a feature-rich environment. It can be seen as made up of two main
parts:
@itemize
@item The S-Lang language. This is a scripting language, with a syntax close to
C/C++. It has many interesting features from a GE point of view, such as:
@itemize
@item It is an interpreted language;
@item It is machine-independent;
@item It allows for dynamic typing;
@item It allows for on-the-fly function declarations.
@end itemize
@item The S-Lang library. This is a library that allows the interpretation of
S-Lang programs from within other programs. It has a powerful interface which
allows for the execution of S-Lang statements through the program in which it
is embedded, including:
@itemize
@item IO statements (file and screen);
@item Math statements;
@item Variable interfacing.
@end itemize
@end itemize

@subsection Usage

Typically, a piece of code is written in S-Lang, and an interpreter is then
called to execute this code. The interpreter can be the S-Lang shell
@command{slsh}, included with the installation package, or the S-Lang library.
If the latter is used, then specific library functions are required to
initialise the interpreter, load code, execute code, and establish variable
interfaces.

@subsection Examples

The package contains a small set of example programs written in S-Lang. There
are no obvious examples of how to interface the S-Lang interpreter with a
program written in another language, such as C/C++.

@subsection Documentation

The documentation is fairly complete, if somewhat hard to follow. It is
available on the project's website, and is composed of four main parts:
@itemize
@item A Guide to the S-Lang Language;
@item S-Lang Library Programmer's Guide;
@item Intrinsic Function Reference;
@item C Library Reference.
@end itemize

@subsection Using with libGE

To use S-Lang with libGE, the first step is to include S-Lang's header (which
will depend on the location of the S-Lang library in your system):

@code{#include<slang.h>}

The next step is to initialise the S-Lang library; assuming S-Lang is being
used to evaluate mathematical expressions, then code similar to the following
would have to be executed:

@code{if ((-1 == SLang_init_slang()) /* basic interpreter functions */}

@code{|| (-1 == SLang_init_slmath())) /* math intrinsics */}

@code{exit(0);}

Next, an interface needs to be established between the S-Lang interpreter and
the program, by associating a local variable (such as @code{fitness}) to a
S-Lang variable (such as @code{fit}):

@code{if (-1==SLadd_intrinsic_variable("fit",&(fitness),SLANG_DOUBLE_TYPE, 0))@{}

@code{exit(0);}

Finally, the mathematical code can be loaded and executed inside the S-Lang
interpreter:

@code{if (-1 == SLang_load_string ("fit=3*5+2*3*sin(5)"))}

@code{exit(0);}

If the code is successful, then the variable @code{fitness}, which is
interfaced with the S-Lang variable @code{fit}, will contain the result of the
mathematical expression.

Note that since the S-Lang library used the math library, your compilation
string should look something like this (depending on your compiler, and on the
location of includes and libraries):

@command{gcc test.c -lslang -lm}

@page
@c --- TinyCC ---
@node TinyCC,Lua,S-Lang,Evaluators
@section TinyCC

@itemize
@item @uref{http://tinycc.org/}
@end itemize

TinyCC is a small but really fast C compiler. It includes an assembler and
linker, so there is no need to use external programs for that. Also, it comes
bundled with libtcc, a library that provides a backend to execute dynamically
generated code.

@subsection License

TinyCC is distributed under the GNU Lesser General Public License.

@subsection Version

The latest version tested with libGE is 0.9.23.

@subsection Installation

The project uses the standard @command{./configure}, @command{make} and
@command{make install} sequence, even though the configure script is not GNU
compliant (i.e., it is not generated by @command{autoconf} and
@command{automake}). This means that a command like @command{make install
prefix=/your/path} will @b{not} work; use @command{./configure
--prefix=/your/path} instead, prior to compilation.

@subsection Main features

Speed is the main feature of TinyCC. The website claims gains of speed of up to
9x when compared with GCC. The libtcc part is particularly useful for GE, as it
provides a backend to compile and execute evolved code. Both the ANSI C and ISO
C99 standards are supported, as well as most of the GNUC extensions.
Additionally, it also provides a memory and bound checker. Finally, it has
started support for the Windows platform as well.

@subsection Usage

To compile a C program, just invoke the compiler with the name of the file as
an argument: @command{tcc code.c}. TinyCC can also be used to interpret shell
scripts written in C language. Additionally, it can also be invoked from within
a program, through libtcc.

@subsection Examples

The package comes bundled with five small examples of C programs and scripts;
one example of how to use libtcc is also provided.

@subsection Documentation

The documentation is available both in the website and in the distribution
package, and consists of a single (long) HTML file. A man page is also
available and installed. The documentation for the usage of libtcc is
practically non-existent (although the example file given is pretty
self-explanatory), and its usage requires parsing the @file{libtcc.h} file for
info on the methods available.

@subsection Using with libGE

Usage of libtcc is pretty straightforward. The first thing to do is to include
the @file{libtcc.h} file (whose location depends of where it was installed):

@code{#include<libtcc.h>}

Next, a @code{TCCState} needs to be created and initialised:

@code{TCCState *s=tcc_new();}

The next step consists in setting the output type to memory, that is, to set
the code to be compiled and ran in memory:

@code{tcc_set_output_type(s,TCC_OUTPUT_MEMORY);}

A string containing the code is then compiled:

@code{tcc_compile_string(s,"double f=3+5*2;");}

The code inside the state then needs to be @i{relocated}:

@code{tcc_relocate(s);}

After these steps, the code is ready and compiled inside the @code{TCCState},
and an interface can then be established. This is done by extracting the
address of the variable @code{f} from within the state (through a
@code{unsigned long} variable), and capturing it with a pointer of the same
type (@code{double}):

@code{unsigned long val;}

@code{double *pf;}

@code{if(tcc_get_symbol(s,&val,"f")) exit(0);}

@code{pf=(double*)(val);}

If the compilation and interface were successful, the result should be in
@code{*pf}. The @code{TCCState} can then finally be deleted:

@code{tcc_delete(s);}

Note that libtcc is a dynamic library, so your compilation
string should look something like this (depending on your compiler, and on the
location of includes and libraries):

@command{gcc test.c -ltcc -ldl}

Usage of lictcc gets substantially more complicated as more features are
required. Please refer to the tcc documentation and to the examples bundled
with libGE (@pxref{Examples}).

@page
@c --- Lua ---
@node Lua,Using your own Evaluator,TinyCC,Evaluators
@section Lua

@itemize
@item @uref{http://www.lua.org/}
@end itemize

Lua is a small language that aims to be embeddable and extendable by providing
@i{meta-mechanisms} for implementing features. So while it does not directly
provide OOP features, it allows for such concepts to extend the language. It
can both be extended by C functions as well as being embedded into C. Lua also
supports anonymous functions similar to lambda functions in LISP and dialects.
Lua is dnamically typed.

@subsection License

Until Lua 4.0, Lua used its own license, which was very close to the zlib
license and others, but not quite the same. Starting with Lua 5.0, Lua is
licensed under the terms of the MIT license; this is a very unrestricted
license, whose sole purpose is to provide the code "as is", with no
restrictions to modify or distribute it, but illibating the developpers of any
responsbilities.

@subsection Version

The latest version tested with libGE is 5.0.2.

@subsection Installation

Lua is written in pure ANSI C, so any ANSI C compliant compiler should be able
to compile it. It contains a @command{configure} script, which is @b{not}
created by @command{autoconf}; its purpose is solely to give information about
possible compilation options. A simple @command{make} (and optional
@command{make install}) should compile Lua.

@subsection Main features

Lua is an extension programming language designed to support general procedural
programming with data description facilities. It also offers good support for
object-oriented programming, functional programming, and data-driven
programming. Lua is intended to be used as a powerful, light-weight
configuration language for any program that needs one. Lua is implemented as a
library, written in clean C (that is, in the common subset of ANSI C and C++).

Being an extension language, Lua works embedded in a host program. This program
can invoke functions to execute a piece of Lua code, can write and read Lua
variables, and can register C functions to be called by Lua code.

The Lua distribution includes a stand-alone embedding program, @command{lua},
that uses the Lua library to offer a complete Lua interpreter.

@subsection Usage

Working with Lua might not be immediately straightforward, because of its
extensive use of a stack, which can hold compiled code, results from function
calls, and is also used for communication with the host program.

A Lua program can be interpreted by the included @command{lua} interpreter; if
using the C API, then a Lua state has to be created, and a Lua program can then
be loaded into it and executed.

@subsection Examples

A series of Lua source code examples are included in the @file{test} directory
of the distribution package. Additionally, many examples are given in the
various documents available.

@subsection Documentation

The documentation available for Lua is extensive. There is a user manual
available in HTML, both in the website and in the distribution package; this
manual is also offered in PS and PDF formats. The website also offers a FAQ
list, a set of seminar slides, a series of Lua Technical Notes, a book
(available both in print and online), and all the academic papers written about
(or using) Lua. Finally, the @uref{http://lua-users.org/} website offers a
wiki, including a tutorial.

@subsection Using with libGE

The first thing that needs to be done is to include the Lua include files
(whose location depends on your system's installation):

@code{#include <lua.h>}

@code{#include <lualib.h>}

@code{#include <lauxlib.h>}

Note that if you're using Lua from within a C++ program, then the include files
should be surrounded by a "C" wrapper:

@code{extern "C" @{}

@code{#include <lua.h>}

@code{#include <lualib.h>}

@code{#include <lauxlib.h>}

@code{@}}

Next, a @code{lua_State} needs to be created and initialised:

@code{lua_State *l=lua_open();}

If you are using mathematical functions, the @code{lua_State} needs to be loaded
with its mathematical library:

@code{luaopen_math(l);}

Assume the program evolved with GE is contained in a string:

@code{char *program="f=3*5+2*3*math.sin(5)";}

The next step consists in compiling the code, through a call to
@code{luaL_loadbuffer()}. If the compilation is successful, the call returns
zero and the resulting code chunck is pushed on the stack. A call to
@code{lua_pcall()} then loads the code chunck from the stack, and runs it in
memory, in protected mode; again, if there are no errors, zero is returned. If
there was an error with either of these functions, an error message is pushed
into the stack, which can be retrieved by the @code{lua_tostring()} function:

@code{error = luaL_loadbuffer(l, program, strlen(program), "line") ||}

@code{lua_pcall(l, 0, 0, 0);}

@code{if(error)@{}

@code{fprintf(stderr, "%s", lua_tostring(l, -1));}

@code{lua_pop(l, 1); /* pop error message from the stack */}

@code{@}}

Assuming the compilation was successful, a call to @code{lua_getglobal()} is
then required, to place the value contained in variable @code{f} on top of the
stack. Once that is done, the @code{lua_tonumber()} function can retrieve the
value of that variable from the top of the stack (index @code{-1}, and place it
on a (previously declared) variable (@code{fit}):

@code{lua_getglobal(l, "f");}

@code{fit=lua_tonumber(l,-1);}

Note that Lua uses two libraries (the actual Lua code routines, and the C API
routines), so you have to link to both; furthermore, if you are using its
mathematical instructions, it needs to link to the math library. So your
compilation string should look something like this (depending on your compiler,
and on the location of includes and libraries):

@command{gcc test.c -llua -llualib -lm}

@page
@c --- Using your own Evaluator ---
@node Using your own Evaluator,,Lua,Evaluators
@section Using your own Evaluator

To use your own evaluator (such as an interpreter, a simulator, a piece of
code, etc), you need to create an interface with it. The phenotype structures
created with libGE can be handled as strings or as a sequence of symbols; you
should choose the representation that best meets your needs.

@c =================================================================== Examples
@node Examples,FAQ,Evaluators,Top
@chapter Examples
@cindex Examples

@menu
* Santa Fe Ant Trail Problem::	Example using the Santa Fe Ant Trail problem.
* Cart Centering Problem::	Example using the Cart Centering problem.
* Intertwined Spirals Problem:: Example using the Intertwined Spirals problem.
@end menu

This chapter describes the examples included in the @file{EXAMPLES} directory.
Most of these examples are standard applications of evolutionary programming,
such as the Santa Fe Ant Trail problem or Symbolic Regression problems. Each
problem includes one or more examples of usage of different search engines and
evaluators.

@node Santa Fe Ant Trail Problem,Cart Centering Problem,,Examples
@include santafeanttrail.texi
@node Cart Centering Problem,Intertwined Spirals Problem, Santa Fe Ant Trail Problem,Examples
@include cartcentering.texi
@node Intertwined Spirals Problem,,Cart Centering Problem,Examples
@include intertwinedspirals.texi

@c ======================================================================== FAQ
@node FAQ,Copying This Manual,Examples,Top
@appendix Frequently Asked Questions
@cindex FAQ
@cindex Frequently Asked Questions
@indent
@b{Q}: When trying to compile libGE, I get the following problem:

@noindent
@code{/usr/include/gcc/darwin/2.95.2/g++/stl_vector.h:}

@noindent
@code{In method `_Vector_base<char,allocator<char> >::~_Vector_base()':}

@noindent
@code{/usr/include/gcc/darwin/2.95.2/g++/stl_vector.h:115:}

@noindent
@code{template instantiation depth exceeds maximum of 17}

@b{A}: This seems to be a limitation of older versions of GCC (specifically,
versions 2.95 or lower). Try using a newer version of GCC; 3.0 or higher is
recommended. (Note: if you have two versions of GCC on your system, specify
which version to use through the @command{configure} script; for example,
@command{./configure CC=gcc-3.0 CXX=g++-3.0}).

@b{Q}: When running the @command{configure} script, the check for GALib fails,
but GALib used to run fine on my system.

@b{A}: The version of GCC you are using now might be different than the one you
used when installing GALib on your system. Try recompiling GALib with the new
compiler.

@b{Q}: My grammar loads without any errors, but I am getting non-terminal
symbols in my phenotype strings, why?

@b{A}: Your BNF specification does not conform with the format accepted by
libGE. Check the examples provided (@pxref{Examples}).

@b{Q}: When compiling a program using GALib with SLang, I get the following
error:

@noindent
@code{/usr/local/include/ga/GA1DArrayGenome.C:342: error: syntax error before
`>' token}

@b{A}: Both GALib and slang took the unfortunate decision of using the variable
@code{ARRAY_TYPE} on their files: slang as an equivalent for its own
@code{SLANG_ARRAY_TYPE}, and GALib as a template name. To solve this problem,
make sure you do @code{#include<ga/ga.h>} @b{before} you do
@code{#include<slang.h>}.

@b{Q}: I am getting the following error:

@noindent
@code{# libGE has been configured to use GALib, but GALib was not found.   #}

@noindent
@code{# Please re-install GALib, or reconfigure libGE and re-install it.   #}

@noindent
@code{# Alternatively, edit the libGEdefs.h file in the include directory. #}

@b{A}: When you originally configured and installed libGE, a copy of GALib was
found on your system, and support for GALib was enabled; however, the GALib
headers can no longer be found. This causes the compilation of any program
using libGE headers to fail, even if they do not use GALib.

The easiest solution is to reconfigure, recompile and reinstall libGE.
Otherwise, remove the line defining the symbol @code{GALIB_INCLUDEPATH} from
the file @file{libGEdefs.h}, which was installed in the libGE include directory
(typically @file{/usr/local/include/GE/libGEdefs.h}).

@c ========================================================= Copying This Manual
@node Copying This Manual,References,FAQ,Top
@appendix Copying This Manual

@include fdl.texi

@c ================================================================= References
@node References,Index,Copying This Manual,Top
@appendix References

@exdent D. E. Goldberg: Genetic Algorithms in Search, Optimization and Machine
Learning. Addison Wesley. (1989)

@exdent M. O'Neill: Automatic Programming in an Arbitrary Language: Evolving
Programs with Grammatical Evolution. PhD Thesis, University of Limerick (2001)

@exdent M. O'Neill and C. Ryan: Grammatical Evolution. IEEE Transactions on
Evolutionary Computation, Vol. @b{5}, No. 4. (2001) 349--358

@exdent M. O'Neill and C. Ryan: Grammatical Evolution - Evolving programs in an
arbitrary language. Kluwer Academic Publishers. (2003)

@exdent R. E. Smith, D. E. Goldberg and J. A. Earickson: SGA-C: A C-language
Implementation of a Simple Genetic Algorithm. TCGA Report No. 91002. (1994)

@exdent C. Ryan and A. Azad: Sensible Initialisation in Grammatical Evolution. In:
GEWS 2003: Grammatical Evolution Workshop, GECCO-2003, Chicago, USA. (2003)

@c ====================================================================== Index
@node Index,,References,Top
@unnumbered Concept Index
@printindex cp

@unnumbered Function Index
@printindex fn

@bye

