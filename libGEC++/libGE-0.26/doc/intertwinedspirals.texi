@c --- Intertwined Spirals Problem ---
@section Intertwined Spirals Problem

@menu
* Intertwined Spirals Grammar::  
* GEspiral.c::
* spiralstart.c::
* spiralend.c::
* WrappedCPhenotype::
* Intertwined Spirals Implementation with GE_MITGALIB::
* Intertwined Spirals Implementation with GE_EO::
* Intertwined Spirals Performance::
@end menu

The intertwined spirals problem is a symbolic regression problem in which
points must classified as belonging to one of two classes. The points of each
class are arranged on the x-y plane so that they are intertwined and spiral out
from the origin.

Lang and Whitbrock first attempted to solve this problem in 1989 using a neural
network. The experiments used 97 coordinates for each class. In 1992, Koza
attempted the problem using GP using three terminals x, y and ERC (a random
constant). The function set included four arithmetic operators, a decision
making function and the trigonometric sine and cosine functions. Koza increased
the number of coordinates on each spiral to 194. Given that only two spirals
needed to be classified, the output of the system was limited to boolean values
by mapping all positive output to +1 and all negative output to -1.

@c --- Intertwined Spirals Grammar ---
@node Intertwined Spirals Grammar, GEspiral.c,,Intertwined Spirals Problem
@subsection Grammar

The grammar used in the GE implementation of the intertwined spirals problem is as follows.

@verbatim
<expr> ::= mymul(<expr>, <expr>) | mysub(<expr>, <expr>)
           | myadd(<expr>, <expr>) | pdiv(<expr>, <expr>)
           | if_cond(<expr>, <expr>, <expr>, <expr>)
	   | (<expr>) 
	   | sin(<expr>) | cos(<expr>) | tan(<expr>) | exp(<expr>)  
	   | x | y | 1.000 | <const> | -<const>
<const> ::= 0.<digit><digit><digit>
<digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
@end verbatim


@c --- GEspiral.c ---

@node GEspiral.c, spiralstart.c, Intertwined Spirals Grammar,Intertwined Spirals Problem
@subsection @file{GEspiral.c}

The file @file{GEspiral.c} provides a number of variable and function
declarations that are required to evaluate GALib individuals using the GCC,
TCC, and libTCC backends. The header file @file{GEspiral.h} provides the
declarations of the functions found in this file. This section documents the
use of each of these functions and variables in the intertwined spirals
problem. The following lists the variables declared in the file.

@itemize
@item @code{xvals} the array of x components of each of the 194 coordinates.
@item @code{yvals} the array of y components of each of the 194 coordinates.
@item @code{Class} the array of true classification values (i.e. +1 or -1 for each of the 194 coordinates.
@item @code{Evolved} the array of classification values as determined by the GE individual.
@item @code{FintessCases} the number of fitness cases (coordinates). In this example, this value is set to 194.
@end itemize

The function @code{initVals} populates the coordinate arrays @code{xvals} and
@code{yvals} with values. The values are arraged in an intertwined spiral
formation about the origin. The class of each coordinate is also stored in the
corresponding index in the array @code{class}.

The function @code{AssignFitness} compares the classification values generated
by the GE individual and stored in the array @code{Evolved} with the true
classification values stored in the array @code{Class}.

The remaining functions in this file @code{if_cond}, @code{pdiv}, @code{myadd},
@code{mysub}, and @code{mymul} provide the implementation of the functions
defined in the grammar file:

@itemize
@item @code{if_cond} a binary decision making function.
@item @code{pdiv} a binary protected division operator.
@item @code{myadd} a binary addition operator.
@item @code{mysub} a binary subtraction operator.
@item @code{mymul} a binary multiplication operator.
@end itemize

@c --- spiralstart.c ---
@node spiralstart.c, spiralend.c, GEspiral.c,Intertwined Spirals Problem
@subsection C Start Code @file{spiralstart.c}

The file @file{spiralstart.c} references the variables and functions defined in
@file{GEspiral.c} by including the header file @file{GEspiral.h} and using the
@code{extern} keyword for the arrays @code{xvals}, @code{yvals}, and
@code{Evolved}.

The file also starts the definition of a @code{main} function in which the
phenotype execution is executed. The function starts with a call to
@code{initVals} (defined in @file{GEspiral.c}. This function initialises the
coordinates of the spirals and stores the x and y components in the arrays
@code{xvals} and @code{yvals} respectively.

The function then construts a for loop to executing the classifier code for
each of the coordinates in the spirals. The current x and y coordinates are
retrieved from the current position in the arrays @code{xvals} and @code{yvals}
and assigned to the working variables @code{x} and @code{y}. Note that these
working variables are references by name in the grammar. The function then
starts an assignment operator in which the result of the classification code is
assigned to the variable temp. The code to complete the program after the
phenotype code is placed at this point is described in the next section.

@c --- spiralend.c ---
@node spiralend.c, WrappedCPhenotype, spiralstart.c,Intertwined Spirals Problem
@subsection C End Code @file{spiralend.c}

The code in the file @file{spiralend.c} completes the assignment operator from
the last line in the file @file{spiralstart.c} and tests if the value assigned
to temp is negative, in which case a value of 0 is stored in the current index
of the array @code{Evolved}. or positive, in which case a 1 is stored. These
values represent the classification of the x and y coordinates as belonging to
either spiral 0 or spiral 1.

Finally, the result of the call to the function @code{AssignFitness} is printed
to standard output. This value will be read by the objective function in the
search engine-specific code described in the following sections.


@c --- WrappedCPhenotype ---
@node WrappedCPhenotype, Intertwined Spirals Implementation with GE_MITGALIB, spiralend.c,Intertwined Spirals Problem
@subsection Example wrapped C phenotype

@verbatim
#include <stdio.h>
#include <math.h>
#include "GEspiral.h"

extern double xvals[194];
extern double yvals[194];
extern int Evolved[194];
int main()
{
 initVals();
 int i;
 double temp,x,y;
 for(i=0;i<194;i++)
   {
     x=xvals[i];
     y=yvals[i];
     temp = x + y;
   if(temp < 0)
     Evolved[i]=0;
   else
     Evolved[i]=1;
 }
 printf("%d\n",AssignFitness());
}
@end verbatim


@page
@c --- Intertwined Spirals Implementation with GE_MITGALIB ---
@node Intertwined Spirals Implementation with GE_MITGALIB, Intertwined Spirals Implementation with GE_EO, WrappedCPhenotype,Intertwined Spirals Problem
@subsection GE_MITGALIB

@menu
* EXAMPLES/IntertwinedSpirals/GE_MITGALIB/main.cpp::  
* EXAMPLES/IntertwinedSpirals/GE_MITGALIB/initfunc.cpp::  
* EXAMPLES/IntertwinedSpirals/GE_MITGALIB/GEListGenome.h::  
* EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-gcc.cpp::  
* EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-slang.cpp::  
* EXAMPLES/IntertwinedSpirals/GE_MITGALIB/GEspiral.sl::  
* EXAMPLES/IntertwinedSpirals/GE_MITGALIB/SLangStartCode::  
* EXAMPLES/IntertwinedSpirals/GE_MITGALIB/SLangEndCode::  
* EXAMPLES/IntertwinedSpirals/GE_MITGALIB/WrappedSLangPhenotype::  
* EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-libtcc.cpp::  
* EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-lua.cpp::  
* EXAMPLES/IntertwinedSpirals/GE_MITGALIB/GEspiral.lua::  
* EXAMPLES/IntertwinedSpirals/GE_MITGALIB/LuaStartCode::  
* EXAMPLES/IntertwinedSpirals/GE_MITGALIB/LuaEndCode::  
* EXAMPLES/IntertwinedSpirals/GE_MITGALIB/WrappedLuaPhenotype::  
* EXAMPLES/IntertwinedSpirals/GE_MITGALIB/Makefile::  
@end menu


This example uses the standard @code{GAParameterList} for passing arguments to specify the parameters of the run. The paramaters specific to GE can also be specified on the command line.

Parameters are passed to the executable in the following fashion:

@command{./executable <param_name> <value>}

The following list shows the parameters accepted by GALib with their default values:

@itemize
@item popsize: population size (default is 100);
@item ngen: population size (default is 10);
@item pcross: crossover probability (default is 0.9);
@item pmut: mutation probability (default is 0.01);
@item prepl: steady-state replacement strategy (default is 1.0);
@item sfreq: how often to record scores (generation interval) (default is 1);
@item ffreq: how often to dump scores to file (generation interval) (default is 1);
@item sfile: name of score data file (default is "is-output.dat").
@item setttings_file: the name of a file with GALib configuration parameters;
@end itemize

@noindent
All other parameters are set to the GALib defaults (check the GALib
documentation for more details).

The following parameters specific to GE can also be specified on the command line.

@itemize
@item seed: random seed to be used both by GALib and libGE (default is random);
@item grammar: grammar file to use (default is "grammar.bnf");
@item wrap: number of wrapping events (default is 0);
@item sensible: use sensible initialisation instead of random (default is 0);
@item min: minimum genotype size for random initialisation (default is 15);
@item max: maximum genotype size for random initialisation (default is 25);
@item grow: grow rate for sensible initialisation (default is 0.5);
@item maxDepth: maximum tree depth for sensible initialisation (default is 10);
@item tailSize: tail size for sensible initialisation (default is 0);
@item tailRatio: tail ratio for sensible initialisation (default is 0.0);
@item effective: use effective crossover instead of one point crossover (default is 0);

@end itemize

For example, to run the @command{GELUA} implementation, using the grammar file
"grammar-lua.bnf", with a population size of 500 individuals, for 50
generations, using random seed 1234, and leaving all other parameters to standard values, the command to execute is:

@command{./GELUA grammar grammar-lua.bnf popsize 500 ngen 50 seed 1234}

@c --- EXAMPLES/IntertwinedSpirals/GE_MITGALIB/main.cpp ---
@node EXAMPLES/IntertwinedSpirals/GE_MITGALIB/main.cpp, EXAMPLES/IntertwinedSpirals/GE_MITGALIB/initfunc.cpp, , Intertwined Spirals Implementation with GE_MITGALIB
@subsubsection @file{main.cpp}

@findex objfunc()
This file drives the evolutionary process. It starts with the declaration of
all functions required to set up and perform the GALib evolver, the definition
of a @code{GEGrammarSI} mapper, the global integers containing minimum and
maximum size information for random initialisation, and a counter for the
number of objective function calls.

After displaying the version of libGE, the function creates the variables for
the parameters specific to GE e.g. the location of the grammar file, the
maximum number of wrapping events allowed, the use of sensible initialisation,
etc. Additional variables are created to store the location of a GALib
parameters file the random seed to use for GALib. Each of the arguments passed
to the program on the command line are then read and values are assigned to the
variables when matched.

A @code{GAParameterList} is then created to specify defaults for a number of
GALib parameters including population size, number of generations, crossover
and mutation probabilities, etc. If a settings file was specified on the
command line, parameters are read from this file by calling the
@code{GAParameterList::read} member function.

Once the parameters have been read, the genome structure is created. In this
example, a class called @code{GEListGenome} is provied (in files
@file{GEListGenome.h} and @file{GEListGenome.cpp}) which derives from the GALib
class @code{GAListGenome}. The fitness function, called @code{objfunc}, is also
associated with the genome using the member function
@code{GAListGenome::evaluator}.

@findex initFuncRandom()
@findex initFuncSI()
@findex OnePointCrossover()
@findex effCrossover()
@findex PointMutator()
The genetic operators to use are specified next. In this example, the default
initialisation function is the random initialiser (@code{initFuncRandom()} but
sensible initialisation is available in the function @code{initFuncSI()}. Both
of these functions are declared in the file @file{initfunc.h} and defined in
the file @file{initfunc.cpp}, The initialiser function is associated with the
genome using the @code{GAGenome::initialiser} member function.

Two crossover operators are available in this example. The default operator,
implemented in the function @code{GAListGenome::OnePointCrossover}, is part of
GALib and provides standard crossover functionality. The other operator,
implemented in the function @code{GEListGenome::effCrossover} limits the
crossover point to locations within the effective region of the genotype. This
function is declared in the file @file{GEListGenome.h} and defined in
@file{GEListGenome.cpp}. This operator and the mutation operator
@code{GEListGenome::pointMutator} are declared in the @file{GEListGenome.h} and
defined in @file{GEListGenome.cpp}. The crossover and mutation operators are
associated with the GALib genome using the @code{GAGenome::crossover} and
@code{GAGenome::mutation} member functions.

@findex app_init()
A call to the function @code{app_init()} follows, which loads the code to place
before and after each evolved phenotype prior to evaluation, and initialises
the libGE mapper; this function is contained in the files @file{spiral-*.cpp} (with @file{*} replaced with the name of the evaluator used).

Next comes the creation of the genetic algorithm @code{ga}, which uses a
steady-state replacement strategy; the @code{GAParameterList} containing all
parameters is associated with it. The mapper is also initialised, using either
default values or the values obtained when parsing the command-line arguments.
Finally, the recorded statistics are selected, a custom statistics file is
created, and a call to the @code{initialize()} method is made, to apply all
settings to the genetic algorithm, including the random seed.

An evolutionary cycle is then performed. This can either be done directly with
@code{ga.evolve()}, or on a step by step cycle, as shown in the example. Also
note how two statistics files are created, one using the GALib standard
outputs, and a second one, illustrating the creation of a personalised
statistics file.

@findex print_individual()
Finally, once the evolution is finished, the statistical data is dumped onto
the screen, as is the best individual of the population (through a call to the
function @code{print_individual()}, defined in the files @file{spiral-*.cpp}).


@c --- EXAMPLES/IntertwinedSpirals/GE_MITGALIB/initfunc.cpp ---
@node EXAMPLES/IntertwinedSpirals/GE_MITGALIB/initfunc.cpp, EXAMPLES/IntertwinedSpirals/GE_MITGALIB/GEListGenome.h, EXAMPLES/IntertwinedSpirals/GE_MITGALIB/main.cpp, Intertwined Spirals Implementation with GE_MITGALIB
@subsubsection @file{initfunc.cpp}

@findex initFuncRandom()
This file contains the two specific initialisation functions designed for this
example, @code{initFuncRandom()} and @code{initFuncSI()}. The first function
randomly initialises each genome in the population. It starts by
destroying any data possibly contained in an individual and then chooses a
number between @code{minSize} and @code{maxSize} (declared and initialised in
@file{main.cpp}) for its size. It then initialises each gene to a number
between 0 and 255, starting with the head of the list.

@findex initFuncSI()
@findex GEGrammarSI.init()
@findex init(), GEGrammarSI
The second function (@code{initFuncSI()}) can be called to use libGE's
sensible initialisation routines to initialise each genome in the population.
It starts by destroying any data possibly contained in an individual and then
uses the @code{init()} method from the mapper to apply the sensible
initialisation routines. If successful, each codon from the mapper's
@code{Genotype} structure is then copied into the genome.


@c --- EXAMPLES/IntertwinedSpirals/GE_MITGALIB/GEListGenome.h ---
@node EXAMPLES/IntertwinedSpirals/GE_MITGALIB/GEListGenome.h, EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-gcc.cpp, EXAMPLES/IntertwinedSpirals/GE_MITGALIB/initfunc.cpp, Intertwined Spirals Implementation with GE_MITGALIB
@subsubsection @file{GEListGenome.h}

This file declares the @code{GEListGenome} class, which is the genome used in
the intertwined spirals example. It derives from GALib's @code{GAListGenome}
class, using the type @code{unsigned char} as its elements, as an
@code{unsigned char} is usually composed of eight bits, which is the standard
number of bits per gene used in Grammatical Evolution.

@findex getEffectiveSize()
@findex setEffectiveSize()
@findex effCrossover()
@findex pointMutator()
This class extends the @code{GAListGenome} by allowing the genome to record its
effective length, that is, the portion of the genome that was actually used
during the mapping process. It also provides two methods, @code{effCrossover()}
and @code{pointMutator()}, which implement a crossover restricted to the
effective lengths of the genomes and GE's standard bit-level mutation,
respectively. The class also provides a number of functions required for
correct operation with GALib including a copy constructor and the @code{clone},
@code{copy}, and @code{equal} functions. The implementation of all these
functions is in the file @file{GEListGenome.cpp}.

@c --- EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-gcc.cpp ---
@node EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-gcc.cpp, EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-slang.cpp, EXAMPLES/IntertwinedSpirals/GE_MITGALIB/GEListGenome.h, Intertwined Spirals Implementation with GE_MITGALIB
@subsubsection @file{spiral-gcc.cpp}

The file @file{spiral-gcc.cpp} contains the functions directly related to the
evaluation of each GALib individual using a C compiler such as GCC. The
following section describes the various files and functions that are part of
the C backend for the intertwined spirals example. This section also describes
how the default compiler, GCC, can be exchanged for another C compiler called
TCC (from the TinyCC distribution).

@findex app_init()
The @code{app_init} function, called from the function @code{main}, is
responsible for initialising the GE mapper and setting up the C evaluation
backend. 

The @code{GEGrammarSI} @code{mapper} object, which is declared in the
@file{main.cpp}, is initialised by specifying the maximum number of mapping
wraps and loading the BNF grammar using the member function @code{readBNFFile}.
Both the number of wrapping events and the path to the grammar file are
specified in parameters to @code{app_init}. If the grammar fails to load, an
error message is printed to the standard error stream (@code{std::cerr}) and
the program exits.

The next task in this function is to load the code that will be placed before
and after the phenotype which is contained in the files @file{spiralstart.c}
and @file{spiralend.c}. The function loads the contents of these files into the
@code{SPstart} and @code{SPend} buffers (character arrays). These buffers are
then used in the @code{objfunc} function for every individual that is evaluated
using the C compiler backend. For more information about these files,
@ref{spiralstart.c}, and @ref{spiralend.c}.

@findex objfunc()
The function @code{objfunc} provides the definition of the evaluation operator
required by GALib. This function takes one argument of type @code{GAGenome} and
returns a floating point value representing the fitness awarded to that
@code{GAGenome} object. In order to evaluate the genome, the GAGenome object
has to be cast into its derived type (@code{GEListGenome}). This allows the
extra member functions specified in the class @code{GEListGenome} to be used in
this function.

Once cast, the @code{GEListGenome} is then assigned to the @code{mapper}
object. A libGE @code{Phenotype} is then extracted from the same @code{mapper}
object. If the phenotype is invalid, a fitness value of 0.0 is returned and the
function exits. If the phenotype is valid, the full executable code needs to be
constructed so that the phenotype can be evaluated in the C backend. 

The first step in this process is to create a new empty file called
@file{individual.c}. The contents of the buffer @code{SPstart} are written out
to this file, followed by the contents of the phenotype, followed by the
contents of the buffer @code{SPend}. The file @file{individual.c} is then
closed. An example @file{individual.c} file is shown in
@ref{WrappedCPhenotype}.

At this point, the file contains a full valid C program which should be
compilable by any C compiler. In this example, two different C compilers can be
used: GCC and TinyCC. If the macro @code{GESPIRAL_USE_TCC_COMP} was defined
when the file @file{spiral-gcc.cpp} was compiled, then the TinyCC C compiler
(called @code{tcc}) is used. If the macro was not defined, the GNU C compiler
(called @code{gcc}) is used. The compiler program is called by invoking a
@code{system} call with the name of the compiler program and the name of the
file containing the phenotype and wrapper code i.e. @file{individual.c}. The
phenotype file is also linked with the object file produced by the compilation
of the file @code{GEspiral.c}. The @code{system} call also invokes the
execution of the compiled program and redirects all standard output to a file
called @file{result}. If the program compiles and the program runs
successfully, the file @file{result} should contain the number of fitness cases
which were classified correctly.

To extact this value, the result file is opened and the first integer value
found is assigned to the variable @code{fitness}. The result file is then
closed.

A number of tests are done on the fitness variable to ensure that it is a
number. Before the function returns this value, it sets the effective size of
the genotype in the genome object. This value is used by the effective
crossover operator.

Before the function returns this value, it sets the effective size of the
genotype in the genome object. This value is used by the effective crossover
operator.

Finally, the fitness is returned and the function exits.

@findex print_individual()
Finally, the @code{print_individual} function receives a genome as argument,
performs its mapping to a phenotype structure, and prints it onto the screen,
along with measurements of the genotype, generated phenotype, and the mapping
process itself.


@c --- EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-slang.cpp ---
@node EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-slang.cpp, EXAMPLES/IntertwinedSpirals/GE_MITGALIB/GEspiral.sl, EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-gcc.cpp, Intertwined Spirals Implementation with GE_MITGALIB
@subsubsection @file{spiral-slang.cpp}

This file contains the functions related to the evaluation of each individual,
made specifically for use with the S-Lang runtime. The following section
describes the various files and functions that are part of the S-Lang backend
for the intertwined spirals example.

@findex app_init()
The @code{app_init} function, called from the @code{main} function, is
responsible for initialising the libGE mapper and initialising the S-Lang
interpreter. 

The @code{GEGrammarSI} mapper object used in this function is declared in the
file @file{main.cpp}. The number of wrapping events and the path to the grammar
are supplied in parameters to this function. The @code{mapper} object is
initialised by specifying the maximum number of mapping wraps and loading the
BNF grammar file using the @code{readBNFFile} member function. If the process
of loading the grammar fails, an error message is printed to the standard error
stream (@code{std::cerr}) and the program exits.

@findex SLang_init_slang()
@findex SLang_init_stdio()
@findex SLang_init_slmath()
The function initialises the S-Lang environment by calling the S-Lang function
@code{SLang_init_slang} and loads the stdio and math runtime libraries by
calling @code{SLang_init_stdio} and @code{SLang_init_slmath}. If any of these
functions fail, the program exits.

@findex SLang_load_file()
Once the S-Lang environment is set up, the file @file{GEspiral.sl} is loaded
using the function @code{SLang_load_file}. This file contains the functions and
variables required to evaluate a GE phenotype and is only required to be loaded
once.

@findex objfunc()
The function @code{objfunc} provides the definition of the evaluation operator
required by GALib. This function takes one argument of type @code{GAGenome} and
returns a floating point value representing the fitness awarded to that
@code{GAGenome} object. In order to evaluate the genome, the GAGenome object
has to be cast into its derived type (@code{GEListGenome}). This allows the
extra member functions specified in the class @code{GEListGenome} to be used in
this function.

Once cast, the @code{GEListGenome} is then assigned to the @code{mapper}
object. Once this is complete, a libGE @code{Phenotype} is then extracted from
the same @code{mapper} object. If the phenotype is invalid, a fitness value of
0.0 is returned and the function exits. If the phenotype is valid, the full
executable code needs to be constructed so that the phenotype can be evaluated
in the S-Lang backend.

Instead of having to construct the program and write it to a file to be
compiled, S-Lang allows the interpretation and execution of the program in
memory. This is achieved in this function by creating a string called
@code{buffer} and appending the start, phenotype, and end code to it. Once the
complete program is constructed, the @code{buffer} string should contain a
program that can execute within the S-Lang runtime. 

@findex SLadd_intrinsic_variable()
In order to extract information from the S-Lang runtime environment, a new C++
variable is added to the environment using the @code{SLadd_intrinsic_variable}
function. This function requires the name of the variable within the S-Lang
environment (called @code{Fitness_Variable} in this example), the address of
the variable in the C/C++ runtime (called @code{fitness} in this example), and
the type of data stored in the variable (@code{SLANG_INT_TYPE}). If any of the
S-Lang functions function fail, the program exits

@findex SLang_load_string()
The contents of the string are executed in the runtime by calling the function
@code{SLang_load_string}. Once execution has completed, the value in the
variable @code{fitness} should contain the number of fitness cases which were
correctly classified.

Before the function returns this value, it sets the effective size of the
genotype in the genome object. This value is used by the effective crossover
operator.

Finally, the fitness is returned and the function exits.

@findex print_individual()
Finally, the @code{print_individual} function receives a genome as argument,
performs its mapping to a phenotype structure, and prints it onto the screen,
along with measurements of the genotype, generated phenotype, and the mapping
process itself.


@c --- EXAMPLES/IntertwinedSpirals/GE_MITGALIB/GEspiral.sl ---
@node EXAMPLES/IntertwinedSpirals/GE_MITGALIB/GEspiral.sl, EXAMPLES/IntertwinedSpirals/GE_MITGALIB/SLangStartCode, EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-slang.cpp, Intertwined Spirals Implementation with GE_MITGALIB
@subsubsection @file{GEspiral.sl}

The file @file{GEspiral.sl} provides the variables and functions required to
evaluate the GE phenotype for the intertwined spirals problem using the S-Lang
runtime.  It provides the functions @code{initVals} and @code{AssignFitness}
and the grammar functions @code{if_cond}, @code{pdiv}, @code{myadd},
@code{mysub}, and @code{mymul}. The functionality of the code is the same as
that found in the file @file{GEspiral.c} and descriptions of the variables and
functions can be found in section @ref{GEspiral.c}.


@c --- EXAMPLES/IntertwinedSpirals/GE_MITGALIB/SLangStartCode ---
@node EXAMPLES/IntertwinedSpirals/GE_MITGALIB/SLangStartCode, EXAMPLES/IntertwinedSpirals/GE_MITGALIB/SLangEndCode, EXAMPLES/IntertwinedSpirals/GE_MITGALIB/GEspiral.sl, Intertwined Spirals Implementation with GE_MITGALIB
@subsubsection S-Lang start code

The code required to invoke the functions in @file{GEspiral.sl} is shown below.
This code is executed just before the GE phenotype in the @code{objfunc}
function described in section
@ref{EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-slang.cpp}.

@verbatim
initVals();
variable i;
variable temp = Double_Type;
variable fit = Double_Type;
fit=0;
for(i=0;i<194;i++)
{
   variable x = Double_Type;
   variable y = Double_Type;
   y=yvals[i];
   x=xvals[i];
   Evolved[i]=
@end verbatim

The code first initialises the variables declared in @file{GEspiral.sl}. Once a
number of working variables are created, the for loop retrieves the x and y
coordinate of the current test case from the coordinate arrays @code{xvals} and
@code{yvals}. The code segment ends with an assignment operation to the current
index in the array @code{Evolved}. This statement is left unfinished to allow
the insertion of the GE phenotype code at this point. The remainder of the code
is explained in the next section
.

@c --- EXAMPLES/IntertwinedSpirals/GE_MITGALIB/SLangEndCode ---
@node EXAMPLES/IntertwinedSpirals/GE_MITGALIB/SLangEndCode, EXAMPLES/IntertwinedSpirals/GE_MITGALIB/WrappedSLangPhenotype, EXAMPLES/IntertwinedSpirals/GE_MITGALIB/SLangStartCode, Intertwined Spirals Implementation with GE_MITGALIB
@subsubsection S-Lang end code

In the previous section, the code segment shows that an assignment operation is
started. The code required to complete this assignment and to evaluate the
fitness of the classification accuracy of the GE phenotype is shown below.

@verbatim
  ;
}
Fitness_Variable=AssignFitness();
@end verbatim

@findex SLadd_intrinsic_variable()
The code completes the assignment statement and closes the for loop from the
start code. Finally, the fitness assigned to the variable
@code{Fitness_Variable}, which is a C variable passed into the S-Lang
environment using the @code{SLadd_intrinsic_variable} function.

@c --- EXAMPLES/IntertwinedSpirals/GE_MITGALIB/WrappedSLangPhenotype ---
@node EXAMPLES/IntertwinedSpirals/GE_MITGALIB/WrappedSLangPhenotype, EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-libtcc.cpp, EXAMPLES/IntertwinedSpirals/GE_MITGALIB/SLangEndCode, Intertwined Spirals Implementation with GE_MITGALIB
@subsubsection Example wrapped S-Lang phenotype

A GE phenotype, complete with start and end code is shown in the following code segment.

@verbatim
initVals();
variable i;
variable temp = Double_Type;
variable fit = Double_Type;
fit=0;
for(i=0;i<194;i++)
{
   variable x = Double_Type;
   variable y = Double_Type;
   y=yvals[i];
   x=xvals[i];
   Evolved[i]= x + y;
}
Fitness_Variable=AssignFitness();
@end verbatim

@c --- EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-libtcc.cpp ---
@node EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-libtcc.cpp, EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-lua.cpp, EXAMPLES/IntertwinedSpirals/GE_MITGALIB/WrappedSLangPhenotype, Intertwined Spirals Implementation with GE_MITGALIB
@subsubsection @file{spiral-libtcc.cpp}

The file @file{spiral-libtcc.cpp} contains the functions directly related to
the evaluation of each GALib individual using the libTCC library (part of the
TinyCC distribution). The intertwined spirals example uses the C API of the
libTCC library to interpret, execute, and evaluate the GE phenotype. Evaluation
of the phenotype in this way results in significant improvements in execution
time over language compilers e.g. GCC, and TCC. The following section describes
the various files and functions that are part of the libTCC backend for the
intertwined spirals example.

@findex app_init()
The function @code{app_init} function, called from the function @code{main} in
the file @file{main.cpp} is responsible for initialising the libGE mapper,
loading the BNF grammar file, and setting up the resources required to evaluate
the GE phenotypes using the libTCC evaluator in the function @code{objfunc}.

The @code{GEGrammarSI} @code{mapper} object, which is declared in the
@file{main.cpp}, is initialised by specifying the maximum number of mapping
wraps @code{wrappingEvents} and the BNF @code{grammarFile} is loaded using the
@code{readBNFFile} member function. Both of these variables are supplied as
parameters to the@code{app_init} function. If the process of loading the
grammar fails, an error message is printed to the standard error stream
(@code{std::cerr}) and the program exits.

In order to minimise the time taken to extract, evaluate and award a fitness to
a GE phenotype, the start and end code that is placed before and after a GE
phenotype are loaded into character buffers in this function. These buffers are
accessed in the function @code{objfunc}, every time a GALib individual needs is
evaluated. In this example, the C code in the file @file{spiralstart.c} and
@file{spiralend.c} are read into the @code{char} arrays @code{SPstart} and
@code{SPend} respectively. The last task in this function is to load the file
@file{GEspiral.c} into another character buffer called @code{GEfunc}. This file
contains the definitions of the functions and variables that will be used
either directly or indirectly by the GE phenotype code. For more information
about these files, @pxref{GEspiral.c} and
@ref{spiralstart.c}, and @ref{spiralend.c}.

@findex objfunc()
The @code{objfunc} function is responsible for evaluating an individual (passed
in the argument @code{g}). The @code{setGenotype()} method from the mapper is
used to create a @code{Genotype} structure within the mapper, from the genome
@code{g}. If the resulting phenotype is not valid, a fitness of 0.0 is returned
and the program exits. If the phenotype is valid, then the evaluation of the
phenotype using the libTCC library proceeds.

@findex tcc_new()
@findex tcc_set_output_type()
@findex tcc_add_library()
The first task is to set up a new libTCC state which can compile and execute C
code. This is achieved by calling the function @code{tcc_new}. The function
@code{tcc_set_output_type} is then called to specify that compilation of the C
code should take place in main memory to maximise performance. The math library
@code{m} is also added to the libTCC state using the @code{tcc_add_library}
function to allow the use of a number of math functions at the evaluation
stage.

@findex tcc_compile_string()
The next step is to make the various functions and variables that are defined
in the code stored in the buffer @code{GEfunc} available in the libTCC state.
This is achieved by calling the function @code{tcc_compile_string} and passing
the current libTCC state and the buffer containing the code. It is important to
note that the code in the buffer @code{GEfunc} is not executed at this stage.
The purpose of this call is simply to compile the code and make it available to
the phenotype code which we will execute next.

@findex tcc_compile_string()
Before the phenotype can be executed in the libTCC state, it must be wrapped
with the start and end code stored in the buffers @code{SPstart} and
@code{SPend}. The @code{char} buffer @code{buffer} is used to store the result
of concatenating the buffer @code{SPstart}, the phenotype code, and the buffer
@code{SPend}. An example of this concatenation is shown in
@ref{WrappedCPhenotype}. This buffer is then passed
to the libTCC state using the @code{tcc_compile_string} function. If the
compilation is successful, the libTCC state contains the executable form of the
wrapped phenotype, the supporting functions, and the variables required to
evaluate the GE phenotype.

@findex tcc_relocate()
@findex tcc_compile_string()
@findex tcc_get_symbol()
In order to execute the code in memory, the @code{main} function (declared in
the file @file{spiralstart.c}) must be explicitly invoked. This function is
accessed by first calling the function @code{tcc_relocate}. This makes all
function and variable symbols accessible through the C interface and should be
called after every call to @code{tcc_compile_string}. The function
@code{tcc_get_symbol} is then called with a pointer to the libTCC state, a
reference to a variable of type @code{unsigned long}, and the name of the
symbol we require ("main"). If the required symbol is found, the
@code{tcc_get_symbol} function stores its address in the @code{unsigned long}
variable. This variable is then cast into a function pointer of type @code{int
(*p_tccMainFunc)()}. The main function can the be invoked in the libTCC state
by calling the function through the pointer i.e. @code{p_tccMainFunc()}.

@findex tcc_get_symbol()
@findex tcc_delete()
One the main function has completed, the function @code{objfunc} must invoke
the function @code{AssignFitness} to retrieve the fitness value of the GE
individual. This is performed using the same method as the main function
invocation shown above. A function pointer which matches the signature of the
function @code{AssignFitness} must first be created. In this example, the
pointer is called @code{p_tccFitnessFunc"}. The libTCC function
@code{tcc_get_symbol} is then called to store the symbol location of this
function in the temporary variable @code{val}. This variable is then cast and
stored in the function pointer. The return value of the @code{AssignFitness}
function can then be retrieved by invoking the function through the pointer in
the normal fashion i.e. @code{fitness = p_tccFitnessFunc();}. The function then
deletes the libTCC state using the function @code{tcc_delete}.

The function then checks that the fitness value is a valid number. If this test
fails, the fitness value is set to 0. 

Before the function returns this value, it sets the effective size of the
genotype in the genome object. This value is used by the effective crossover
operator.

Finally, the fitness is returned and the function exits.

@findex print_individual()
Finally, the @code{print_individual} function receives a genome as argument,
performs its mapping to a phenotype structure, and prints it onto the screen,
along with measurements of the genotype, generated phenotype, and the mapping
process itself.


@c --- EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-lua.cpp ---
@node EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-lua.cpp, EXAMPLES/IntertwinedSpirals/GE_MITGALIB/GEspiral.lua, EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-libtcc.cpp, Intertwined Spirals Implementation with GE_MITGALIB
@subsubsection @file{spiral-lua.cpp}

The file @file{spiral-lua.cpp} contains the functions directly related to the
evaluation of each GALib individual using the Lua evaluator. The intertwined
spiral uses the C API of the Lua library to interpret, execute, and evaluate
the GE phenotype. Evaluation of the phenotype in this way results in
significant improvements in execution time over language compilers e.g. GCC,
and TCC. The following section describes the various files and functions that
are part of the Lua backend for the intertwined spirals example.

In order to access the Lua C API through the C++ code in @file{spiral-lua.cpp},
the @code{#include <header.h>} directives must be enclosed in a special
directive called @code{extern "C"} e.g.
@verbatim
extern "C"
{
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
}
@end verbatim
This tells the compiler that the code in these files is C code and not C++ code.
The functions in the file @file{spiral-lua.cpp} make use of the GE
@code{GEGrammarSI} mapper, defined in the @file{main.cpp} file. A global
pointer to a @code{lua_State}, called @code{L} in this example, is also created
at the top of the file.for use by all the functions in the file.

@findex app_init()
The @code{app_init} function, called from the @code{main} function, is
responsible for initialising the libGE mapper and initialising the Lua
interpreter.

The @code{GEGrammarSI} mapper object used in this function is declared in the
file @file{main.cpp}. The number of wrapping events and the path to the grammar
are supplied in parameters to this function. The @code{mapper} object is
initialised by specifying the maximum number of mapping wraps and loading the
BNF grammar file using the @code{readBNFFile} member function. If the process
of loading the grammar fails, an error message is printed to the standard error
stream (@code{std::cerr}) and the program exits.

@findex lua_open()
@findex luaL_openlibs()
The Lua state is opened in this function by a call to the lua API function
@code{lua_open}. Additional math and io libraries are added to this state using
the function @code{luaL_openlibs}. Once completed, the Lua state is then ready
to interpret and execute Lua code.

@findex luaL_dofile()
@findex lua_tostring()
In order to minimise the time required for individual evaluations in the
function @code{objfunc}, the Lua code in @file{GEspiral.lua} is loaded into the
state using the function @code{luaL_dofile}. This function loads and executes
the Lua code in this file which is discussed in more detail in
@ref{EXAMPLES/IntertwinedSpirals/GE_MITGALIB/GEspiral.lua}. It is important to
note that, because the file only contains variable declarations and function
implementations, no code is executed at this time. If an error occurs while
loading this file, Lua sets a error message at the top of its call stack. Each
element on the Lua stack has an index e.g. an index of @code{-1} represents the
element at the top of the stack. This index value is supplied to
the@code{lua_tostring} to retrieve the error message. The message is then
printed to standard error output and the program exits.

@findex objfunc()
The function @code{objfunc} provides the definition of the evaluation operator
required by GALib. This function takes one argument of type @code{GAGenome} and
returns a floating point value representing the fitness awarded to that
@code{GAGenome} object. In order to evaluate the genome, the GAGenome object
has to be cast into its derived type (@code{GEListGenome}). This allows the
extra member functions specified in the class @code{GEListGenome} to be used in
this function.

Once cast, the @code{GEListGenome} is then assigned to the @code{mapper}
object. A libGE @code{Phenotype} is then extracted from the same @code{mapper}
object. If the phenotype is invalid, a fitness value of 0.0 is returned and the
function exits. If the phenotype is valid, the full executable code needs to be
constructed so that the phenotype can be evaluated in the Lua backend.

Instead of writing the phenotype code to a new file, the code is constructed in
memory by appending the required start code, phenotype code, and end code to a
@code{string} object (The start and end code are described in
@ref{EXAMPLES/IntertwinedSpirals/GE_MITGALIB/LuaStartCode} and
@ref{EXAMPLES/IntertwinedSpirals/GE_MITGALIB/LuaEndCode}).

@findex luaL_dostring()
This code is executed in the Lua runtime by calling the function
@code{luaL_dostring} and passing it a pointer to the Lua state and the buffer
containing the code to be executed. If execution fails, the error message is
retrieved from the Lua stack and printed to standard error output and the
program exits.

@findex lua_getglobal()
@findex lua_isnumber()
@findex lua_tonumber()
If the compilation and execution is successful, the function
@code{lua_getglobal} is called to retrieve the Lua variable
@code{sumFitCaseTimes}. This function pushes the variable on to the top of the
stack. The value is checked and retrieved from the stack using the functions
@code{lua_isnumber} and @code{lua_tonumber}. The value is then assigned to the
@code{fitness} variable.

Before returning the fitness value, the effective size of the GE genotype is
stored in the mapper object using the @code{setEffectiveSize} member function
of the @code{GEListGenome} class.

Finally, the fitness is returned and the function exits.


@findex print_individual()
Finally, the @code{print_individual} function receives a genome as argument,
performs its mapping to a phenotype structure, and prints it onto the screen,
along with measurements of the genotype, generated phenotype, and the mapping
process itself.

@c --- EXAMPLES/IntertwinedSpirals/GE_MITGALIB/GEspiral.lua ---
@node EXAMPLES/IntertwinedSpirals/GE_MITGALIB/GEspiral.lua, EXAMPLES/IntertwinedSpirals/GE_MITGALIB/LuaStartCode, EXAMPLES/IntertwinedSpirals/GE_MITGALIB/spiral-lua.cpp, Intertwined Spirals Implementation with GE_MITGALIB
@subsubsection @file{GEspiral.lua}

The file @file{GEspiral.lua} defines the variables and functions required to
evaluate the GE phenotype for the intertwined spirals problem using the Lua
runtime. It provides the functions @code{initVals} and @code{AssignFitness} and
the grammar functions @code{if_cond}, @code{pdiv}, @code{myadd}, @code{mysub},
@code{mymul} and @code{myadd}. The functionality of the code is the same as
that found in the file @file{GEspiral.c} and descriptions of the variables and
functions can be found in @ref{GEspiral.c}.

@c --- EXAMPLES/IntertwinedSpirals/GE_MITGALIB/LuaStartCode ---
@node EXAMPLES/IntertwinedSpirals/GE_MITGALIB/LuaStartCode, EXAMPLES/IntertwinedSpirals/GE_MITGALIB/LuaEndCode, EXAMPLES/IntertwinedSpirals/GE_MITGALIB/GEspiral.lua, Intertwined Spirals Implementation with GE_MITGALIB
@subsubsection Lua start code

In order to execute the phenotype in the Lua state, code must be prepended and
appended to the phenotype. The following code segment shows the code that is
prepended to the phenotype. It starts with a call to @code{initVals} defined in
@file{GEspiral.lua} and then sets up some temporary variables. It also sets up
a for loop to iterate over each test case. In the body of this loop, the
current test case coordinates are retrieved and an assignment statement is
started. This statement is left open to allow the addition of the GE phenotype
code. The code that is appended to the phenotype code in order to construct a
valid Lua program is described in the next section.

@verbatim

initVals(); 
temp = 0.0; 
fit = 0.0; 
for i=0,193,1 do ";
    x=xvals[i]; 
    y=yvals[i]; 
    temp=
@end verbatim

@c --- EXAMPLES/IntertwinedSpirals/GE_MITGALIB/LuaEndCode ---
@node EXAMPLES/IntertwinedSpirals/GE_MITGALIB/LuaEndCode, EXAMPLES/IntertwinedSpirals/GE_MITGALIB/WrappedLuaPhenotype, EXAMPLES/IntertwinedSpirals/GE_MITGALIB/LuaStartCode, Intertwined Spirals Implementation with GE_MITGALIB
@subsubsection Lua end code

The following code is appended to the phenotype to complete the assignment
statement started in the start code and to evaluate the class which should be
assigned to the current test case. If the value of the phenotype (stored in
@code{temp} is less than 0, then the class of the test case is 0. If the
phenotype evaluated to 0 or greater, then the class of the test case is 1. The
class is stored in the array @code{Evolved} (declared in  @file{GEspiral.lua}).

@verbatim
   ; 

   if temp < 0 then 
        Evolved[i]=0; 
   else 
        Evolved[i]=1; 
   end 
end
Fitness_Variable = AssignFitness();
@end verbatim


@c --- EXAMPLES/IntertwinedSpirals/GE_MITGALIB/WrappedLuaPhenotype ---
@node EXAMPLES/IntertwinedSpirals/GE_MITGALIB/WrappedLuaPhenotype, EXAMPLES/IntertwinedSpirals/GE_MITGALIB/Makefile, EXAMPLES/IntertwinedSpirals/GE_MITGALIB/LuaEndCode, Intertwined Spirals Implementation with GE_MITGALIB
@subsubsection Example wrapped Lua phenotype

A phenotype complete with start and end code is shown below as an example.

@verbatim
initVals(); 
temp = 0.0; 
fit = 0.0; 
for i=0,193,1 do ";
    x=xvals[i]; 
    y=yvals[i]; 
    temp=x + y;

   if temp < 0 then 
        Evolved[i]=0; 
   else 
        Evolved[i]=1; 
   end 
end
Fitness_Variable = AssignFitness();
@end verbatim


@c --- EXAMPLES/IntertwinedSpirals/GE_MITGALIB/Makefile ---
@node EXAMPLES/IntertwinedSpirals/GE_MITGALIB/Makefile,  , EXAMPLES/IntertwinedSpirals/GE_MITGALIB/WrappedLuaPhenotype, Intertwined Spirals Implementation with GE_MITGALIB
@subsubsection @file{Makefile}

The @file{Makefile} contained in the example allows you to create a program
using a choice of evaluators for your phenotype strings. Use @command{make} to
create all executables, or @command{make GE*} to create a specific evaluator
implementation (where @command{*} is any of @command{GCC}, @command{SLANG},
@command{TCC}, @command{LIBTCC}, or @command{LUA}). At the top of the file
there are definitions for the location of the GALib, GE, and evaluator specific
header and library files. If you have installed any of these in non-standard
locations, make sure the values are adjusted to suit your system.

Note: Some of the evaluators require the pre-compilation of the
@file{GEspiral.c}. This is automatically done by the @file{Makefile} when the
relevant evaluators are chosen.


@page
@c --- Intertwined Spirals Implementation with GE_EO ---
@node Intertwined Spirals Implementation with GE_EO, Intertwined Spirals Performance, Intertwined Spirals Implementation with GE_MITGALIB,Intertwined Spirals Problem
@subsection GE_EO

@menu
* Intertwined Spirals EO Example User Guide::  
* EXAMPLES/IntertwinedSpirals/GE_EO/GEEA.cpp::  
* EXAMPLES/IntertwinedSpirals/GE_EO/eoGE.h::  
* EXAMPLES/IntertwinedSpirals/GE_EO/eoGEInit.h::  
* EXAMPLES/IntertwinedSpirals/GE_EO/eoGEMutation.h::  
* EXAMPLES/IntertwinedSpirals/GE_EO/eoGEQuadCrossover.h::  
* EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-gcc_tcc.h::  
* EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-slang.h::  
* EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-libtcc.h::  
* EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-lua.h::  
* EXAMPLES/IntertwinedSpirals/GE_EO/Makefile::  
@end menu


The example using the Evolutionary Objects (EO) library can be found in
@file{EXAMPLES/IntertwinedSpirals/GE_EO}. The following sections contain a
user's guide and a description of the files in this example.

@c ---  Intertwined Spirals EO Example User Guide ---
@node Intertwined Spirals EO Example User Guide, EXAMPLES/IntertwinedSpirals/GE_EO/GEEA.cpp, Intertwined Spirals Implementation with GE_EO, Intertwined Spirals Implementation with GE_EO
@subsubsection EO Example User Guide

The EO library has a powerful command-line parser, which is fully-configurable. This example uses that parser to specify both the standard GA parameters, and also the GE specific parameters.

Parameters are passed to the executable in the following fashion:

@command{./executable -param_short_name[=value]}

or

@command{./executable --param_long_name[=value]}

The following are the parameters accepted by this example, and their default values:

@itemize
@item -h, --help: prints help message (default is 0);
@item --stopOnUnknownParam: stop if unknown parameter entered (default is 1);
@item -C, --pCross: probability of crossover (default is 0.9);
@item -E, --effCross: use effective crossover (default is 0);
@item -M, --pMut: probability of mutation (default is 1);
@item -b, --pMutPerBit: probability of bit-flip mutation (default is 0.01);
@item -s, --sensibleInit: use sensible initialisation (default is 0);
@item -x, --minSize: minimum size for random initialisation (default is 15);
@item -X, --maxSize: maximum size for random initialisation (default is 25);
@item -r, --grow: grow ratio for SI (default is 0.5);
@item -d, --maxDepth: maximum depth for SI (default is 10);
@item -T, --tailSize: tail size for SI (default is 0);
@item -t, --tailRatio: tail ratio for SI (default is 0);
@item -g, --grammarFile: grammar file (default is "grammar.bnf");
@item -w, --wrappingEvents: number of wrapping events (default is 0);
@item -L, --Load: save file to restart run (no default);
@item -S, --Status: status file (default is "./<name_of_executable>.status");
@item -R, --seed: random number seed (default is random);
@item -P, --popSize: population size (default is 100);
@item -G, --maxGen: maximum number of generations (default is 10).
@end itemize

For example, to run the @command{GELUA} implementation, using the grammar file "grammar.bnf", with a population size of 500 individuals, for 50 generations, using random seed 1, and leaving all other parameters to standard values, the command to execute is:

@command{GELUA -g=grammar.bnf -P=500 -G=50 -R=1}


@c --- EXAMPLES/IntertwinedSpirals/GE_EO/GEEA.cpp ---
@node EXAMPLES/IntertwinedSpirals/GE_EO/GEEA.cpp, EXAMPLES/IntertwinedSpirals/GE_EO/eoGE.h, Intertwined Spirals EO Example User Guide, Intertwined Spirals Implementation with GE_EO
@subsubsection @file{GEEA.cpp}

The file @file{GEEA.cpp} contains the @code{main()} function, and is the
central point of control over the evolutionary process. It begins by including
all required EO include files, followed by a declaration of the fitness type to
be used, and the type of each individual. The typedef directive declares the
type @code{Indi} as a substitute name for the individual type
@code{eoGE<MyFitT>}. The class eoGE is declared in the file @file{eoGE.h} and
is discussed in the next section. This example uses a custom genotype structure
because EO does not have direct support for variable-length integer-based
structures. The file @file{GEEA.cpp} also declares the libGE @code{GEGrammarSI}
mapper.

The function @code{main_function()} starts by defining all parameters available
to the system using an instance of the @code{eoParser} class. The name of the
parameter, the associated help messages, and the default value are supplied to
the @code{eoParser::createParam} member function.

The fitness operator is then declared by creating an instance of the template
class @code{eoGEEvalFunc}. The template in this case concerns the type of
individual to be evaluated (called @code{Indi} in this example). The operator
object is supplied with the libGE mapper object and the path of the BNF grammar
file to use. 

A number of fitness operator classes are provided in the intertwined spirals
example for EO which use a differend backend platform to evaluate the GE
phenotype. Each of the evaluation backends are implemented in files named
@file{eoGEEvalFunc-*.cpp} with @file{*} replaced by the name of the backend
e.g. @file{eoGEEvalFunc-slang.cpp}. All the fitness operator classes are called
@code{eoGEEvalFunc} and each implements the interface required by EO i.e. they
implement an operator function @code{()} which takes an eo individual,
evaluates it, and then assigns a fitness value. The particular backend fitness
operator class created at execution time is determined during compilation. It
is therefore sufficient at this point to create an instance of the class using
the name @code{eoGEEvalFunc}. The compilation process is described in more
detail later in this section.

The function @code{main_function} then declares an objective function call
counter and a @code{eoPOP} object to store the population of @code{Indi}
individuals.

The random seed generator and the @code{Indi} population are then registered
with a new instance of the class @code{eoState}. This class is responsible for
initialising and evaluating the population in the case of a new run, or loading
the population from disk if continuing a previous run.

The definition of roulette-wheel selection and steady-state replacement (GE
style) follow, along with the definition of the genetic operators to use (which
are encapsulated into a @code{eoTransform} object). Finally, a series of
continuators, checkpoints, statistics objects and monitors are defined and
associated together. For more information on these settings, see the EO
documentation.

At the end of the function @code{main_function}, the actual evolutionary
algorithm object is declared. This @code{eoEasyEA} instance is associated with
the defined checkpoints, evaluation function, selection procedure, genetic
operators, and replacement mechanism. The evolutionary cycle consists merely of
associating the EA object with the current population object @code{pop}.

The function @code{main}, declared at the bottom of the file @file{GEEA.cpp}
consists of a protected call to the function @code{main_function} in a
try/catch block to handle any execution exceptions.


@c --- EXAMPLES/IntertwinedSpirals/GE_EO/eoGE.h ---
@node EXAMPLES/IntertwinedSpirals/GE_EO/eoGE.h, EXAMPLES/IntertwinedSpirals/GE_EO/eoGEInit.h, EXAMPLES/IntertwinedSpirals/GE_EO/GEEA.cpp, Intertwined Spirals Implementation with GE_EO
@subsubsection @file{eoGE.h}

The file @file{eoGE.h} defines the class @code{eoGE}, which represents a
genome. The @code{eoGE} genome consists of a vector of @code{unsigned char}
elements. This type was chosen because it is typically represented by 8 bits,
which is the standard size of GE codons.

The methods @code{printOn()} and @code{readFrom()} output or read a genome
using a standard input or output stream respectively. The method
@code{getEffectiveSize()} merely returns the recorded effective size of the
genotype of this individual.


@c --- EXAMPLES/IntertwinedSpirals/GE_EO/eoGEInit.h ---
@node EXAMPLES/IntertwinedSpirals/GE_EO/eoGEInit.h, EXAMPLES/IntertwinedSpirals/GE_EO/eoGEMutation.h, EXAMPLES/IntertwinedSpirals/GE_EO/eoGE.h, Intertwined Spirals Implementation with GE_EO
@subsubsection @file{eoGEInit.h}

The file @file{eoGEInit.h} defines the class @code{eoGEInit} which contains
member functions for population initialisation. The constructor of the class
reads, processes, and stores the related EO parameters to select a random or a
sensible method for population initialisation.

In the case of a random initialisation, the method @code{operator()} calls
the method @code{randomInit()}. This method creates individuals between the
sizes @code{minSize} and @code{maxSize} containing random @code{unsigned char} numbers.

@findex GEGrammarSI.init()
@findex init(), GEGrammarSI
If sensible initialisation is selected, the mapper's @code{init()} method
is called, and if successful, the contents of its @code{Genotype} structure are
used to initialise the @code{_genotype} object passed as an argument.


@c --- EXAMPLES/IntertwinedSpirals/GE_EO/eoGEMutation.h ---
@node EXAMPLES/IntertwinedSpirals/GE_EO/eoGEMutation.h, EXAMPLES/IntertwinedSpirals/GE_EO/eoGEQuadCrossover.h, EXAMPLES/IntertwinedSpirals/GE_EO/eoGEInit.h, Intertwined Spirals Implementation with GE_EO
@subsubsection @file{eoGEMutation.h}

The file @file{eoGEMutation.h} declares the class @code{eoGEMutation}, which
implements a point mutation operator, as used in standard GE. The mutation is
applied to genotypes as arguments to the @code{operator()} method (the
probability of mutation is supplied in an argument to the constructor).

@c --- EXAMPLES/IntertwinedSpirals/GE_EO/eoGEQuadCrossover.h ---
@node EXAMPLES/IntertwinedSpirals/GE_EO/eoGEQuadCrossover.h, EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-gcc_tcc.h, EXAMPLES/IntertwinedSpirals/GE_EO/eoGEMutation.h, Intertwined Spirals Implementation with GE_EO
@subsubsection @file{eoGEQuadCrossover.h}

The file @file{eoGEQuadCrossover.h} declares the class
@code{eoGEQuadCrossover}, which implements the crossover operator to use during
the evolutionary cycle. Its constructor receives a boolean argument stating
whether to use a standard 1-point crossover or an effective crossover method.

If standard 1-point crossover is specified, a random cut point is selected
within each individual. If effective crossover is selected, each cut point must
lie within the effective part of each individual (that is, the part of its
genome which has been read to create a phenotype). After choosing the cut
points, the second half of each individual is then swapped.


@c --- EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-gcc_tcc.h ---
@node EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-gcc_tcc.h, EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-slang.h, EXAMPLES/IntertwinedSpirals/GE_EO/eoGEQuadCrossover.h, Intertwined Spirals Implementation with GE_EO
@subsubsection @file{eoGEEvalFunc-gcc_tcc.h}

The file @file{eoGEEvalFunc-gcc_tcc.cpp} contains the functions directly
related to the evaluation of each EO individual using a C compiler such as GCC.
The following section describes the various files and functions that are part
of the GCC backend for the intertwined spirals example. This section also
describes how GCC can be exchanged for another C compiler called TCC (from the
TinyCC distribution).

The class @code{eoGEEvalFunc} is a template class which allows the individual
type @code{EOT} to be specified when an instance of the class is created. The
constructor is responsible for initialising the GE mapper and setting up the C
evaluator backend. The @code{mapper} object is initialised by specifying the
maximum number of mapping wraps and loading the BNF grammar file using the
@code{readBNFFile} member function. Each of these values are supplied as
parameters to the constructor function. If the process of loading the grammar
fails, an error message is printed to the standard error stream
(@code{std::cerr}) and the program exits.

The next task in this function is to load the code that will be placed before
and after the phenotype which is contained in the files @file{spiralstart.c}
and @file{spiralend.c}. The function loads the contents of these files into the
@code{SPstart} and @code{SPend} buffers (character arrays). These buffers are
then used in the @code{objfunc} function for every individual that is evaluated
using the C compiler backend. For more information about these files,
@ref{spiralstart.c}, and @ref{spiralend.c}.

The member @code{operator()} provides the definition of the operator required
by EO for individual evaluation. It takes one argument of type @code{EOT} which
represents an EO individual. The function first checks that this individual has
not been evaluated previously by calling the member function
@code{EOT::invalid}. If the individual is invalid, then it needs to be
evaluated and assigned a fitness.  If the individual is valid, the function
exits.

In order to evaluate this individual, the mapper must be supplied with a valid
libGE structure. This is constructed by generating an array of integers and
copying each element from the EO individual. This array is then supplied to the
constructor of the @code{Genotype} object. This is then assigned to the
@code{mapper} object using the member function @code{setGenotype}. Once this is
complete, a libGE @code{Phenotype} is extracted from the @code{mapper} object.
If the phenotype is invalid, a fitness value of 0.0 is returned and the
function exits. If the phenotype is valid, the full executable code needs to be
constructed so that the phenotype can be evaluated in the C backend.

The first step in this process is to create a new empty file called
@file{individual.c}. The contents of the buffer @code{SPstart} are written out
to this file, followed by the contents of the phenotype, followed by the
contents of the buffer @code{SPend}. The file @file{individual.c} is then
closed. An example @file{individual.c} file is shown in
@ref{WrappedCPhenotype}.

At this point, the file contains a full valid C program which should be
compilable by any C compiler. In this example, two different C compilers can be
used: GCC and TinyCC. If the macro @code{GESPIRAL_USE_TCC_COMP} was defined
when the file @file{spiral-gcc.cpp} was compiled, then the TinyCC C compiler
(called @code{tcc}) is used. If the macro was not defined, the GNU C compiler
(called @code{gcc}) is used. The compiler program is called by invoking a
@code{system} call with the name of the compiler program and the name of the
file containing the phenotype and wrapper code i.e. @file{individual.c}. The
phenotype file is also linked with the object file produced by the compilation
of the file @code{GEspiral.c}. The @code{system} call also invokes the
execution of the compiled program and redirects all standard output to a file
called @file{result}. If the program compiles and the program runs
successfully, the file @file{result} should contain the number of fitness cases
which were classified correctly.

To extact this value, the result file is opened and the first integer value
found is assigned to the variable @code{fitness}. The result file is then
closed.

A number of tests are done on the fitness variable to ensure that it is a
number. Finally, the fitness is assigned to the EO individual using the member
function @code{EOT::fitness}. The function then exits.


@c --- EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-slang.h ---
@node EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-slang.h, EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-libtcc.h, EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-gcc_tcc.h, Intertwined Spirals Implementation with GE_EO
@subsubsection @file{eoGEEvalFunc-slang.h}

The file @file{eoGEEvalFunc-slang.h} declares the class @code{eoGEEvalFunc}
required by EO for individual evaluation. This implementation uses the S-Lang
library.

The class @code{eoGEEvalFunc} is a template class which allows the individual
type @code{EOT} to be specified when an instance of the class is created. The
constructor is responsible for initialising the GE mapper and setting up the
GCC or TCC evaluator backend. The @code{mapper} object is initialised by
specifying the maximum number of mapping wraps and loading the BNF grammar file
using the @code{readBNFFile} member function. Each of these values are supplied
as parameters to the constructor function. If the process of loading the
grammar fails, an error message is printed to the standard error stream
(@code{std::cerr}) and the program exits.

@findex SLang_init_slang()
@findex SLang_init_stdio()
@findex SLang_init_slmath()
The function initialises the S-Lang environment by calling the S-Lang function
@code{SLang_init_slang} and loads the stdio and math runtime libraries by
calling @code{SLang_init_stdio} and @code{SLang_init_slmath}. If any of these
functions fail, the program exits.

@findex SLang_load_file()
Once the S-Lang environment is set up, the file @file{GEspiral.sl}
(@pxref{EXAMPLES/IntertwinedSpirals/GE_MITGALIB/GEspiral.sl}) is loaded using
the function @code{SLang_load_file}. This file contains the functions and
variables required to evaluate a GE phenotype and is only required to be loaded
once.

The member @code{operator()} provides the definition of the operator required
by EO for individual evaluation. It takes one argument of type @code{EOT} which
represents an EO individual. The function first checks that this individual has
not been evaluated previously by calling the member function
@code{EOT::invalid}. If the individual is invalid, then it needs to be
evaluated and assigned a fitness. If the individual is valid, the function
exits.

In order to evaluate this individual, the mapper must be supplied with a valid
libGE structure. This is constructed by generating an array of integers and
copying each element from the EO individual. This array is then supplied to the
constructor of the @code{Genotype} object. This is then assigned to the
@code{mapper} object using the member function @code{setGenotype}. Once this is
complete, a libGE @code{Phenotype} is extracted from the @code{mapper} object.
If the phenotype is invalid, a fitness value of 0.0 is returned and the
function exits. If the phenotype is valid, the full executable code needs to be
constructed so that the phenotype can be evaluated in the S-Lang backend.

Instead of having to construct the program and write it to a file to be
compiled, S-Lang allows the interpretation and execution of the program in
memory. This is achieved in this function by creating a string called
@code{buffer} and appending the start, phenotype, and end code to it. Once the
complete program is constructed, the @code{buffer} string should contain a
program that can execute within the S-Lang runtime.

@findex SLadd_intrinsic_variable()
In order to extract information from the S-Lang runtime environment, a new C++
variable is added to the environment using the @code{SLadd_intrinsic_variable}
function. This function requires the name of the variable within the S-Lang
environment (called @code{Fitness_Variable} in this example), the address of
the variable in the C/C++ runtime (called @code{fitness} in this example), and
the type of data stored in the variable (@code{SLANG_INT_TYPE}). If any of the
S-Lang functions function fail, the program exits.

@findex SLang_load_string()
The contents of the string are executed in the runtime by calling the function
@code{SLang_load_string}. Once execution has completed, the value in the
variable @code{fitness} should contain the number of fitness cases which were
correctly classified.

A number of tests are done on the fitness variable to ensure that it is a number. Finally, the fitness is assigned to the EO individual using the member function @code{EOT::fitness}. The function then exits.


@c --- EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-libtcc.h ---
@node EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-libtcc.h, EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-lua.h, EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-slang.h, Intertwined Spirals Implementation with GE_EO
@subsubsection @file{eoGEEvalFunc-libtcc.h}

The file @file{eoGEEvalFunc-slang.h} declares the class @code{eoGEEvalFunc}
required by EO for individual evaluation. This implementation uses the libTCC
library provided in the TinyCC distribution.

The class @code{eoGEEvalFunc} is a template class which allows the individual
type @code{EOT} to be specified when an instance of the class is created. The
constructor is responsible for initialising the GE mapper and setting up the
libTCC evaluator backend. The @code{mapper} object is initialised by specifying
the maximum number of mapping wraps and loading the BNF grammar file using the
@code{readBNFFile} member function. Each of these values are supplied as
parameters to the constructor function. If the process of loading the grammar
fails, an error message is printed to the standard error stream
(@code{std::cerr}) and the program exits.

In order to minimise the time taken to extract, evaluate and award a fitness to
a GE phenotype, the start and end code that is placed before and after a GE
phenotype are loaded into character buffers in this function. These buffers are
accessed in the function @code{objfunc} because they are required for every
GALib individual. In this example, the C code in the file @file{spiralstart.c}
and @file{spiralend.c} are read into the @code{char} arrays @code{SPstart} and
@code{SPend} respectively. The last task in this function is to load the file
@file{GEspiral.c} into another character buffer called @code{GEfunc}. This file
contains the definitions of the functions and variables used either directly or
indirectly by the GE phenotype code. For more information about these files,
@pxref{GEspiral.c} and @ref{spiralstart.c}, and @ref{spiralend.c}.

The member @code{operator()} provides the definition of the operator required
by EO for individual evaluation. It takes one argument of type @code{EOT} which
represents an EO individual. The function first checks that this individual has
not been evaluated previously by calling the member function
@code{EOT::invalid}. If the individual is invalid, then it needs to be
evaluated and assigned a fitness. If the individual is valid, the function
exits.

In order to evaluate this individual, the mapper must be supplied with a valid
libGE structure. This is constructed by generating an array of integers and
copying each element from the EO individual. This array is then supplied to the
constructor of the @code{Genotype} object. This is then assigned to the
@code{mapper} object using the member function @code{setGenotype}. Once this is
complete, a libGE @code{Phenotype} is extracted from the @code{mapper} object.
If the phenotype is invalid, a fitness value of 0.0 is returned and the
function exits. If the phenotype is valid, the full executable code needs to be
constructed so that the phenotype can be evaluated in the libTCC backend.

@findex tcc_new()
@findex tcc_set_output_type()
@findex tcc_add_library()
The first task is to set up a new libTCC state which can compile and execute C
code. This is achieved by calling the function @code{tcc_new}. The function
@code{tcc_set_output_type} is then called to specify that compilation of the C
code should take place in main memory to maximise performance. The math library
@code{m} is also added to the libTCC state using the @code{tcc_add_library}
function to allow the use of a number of math functions at the evaluation
stage.

@findex tcc_compile_string()
@findex tcc_relocate()
The next step is to make the various functions and variables that are defined
in the code stored in the buffer @code{GEfunc} available in the libTCC state.
This is achieved by calling the function @code{tcc_compile_string}, and
supplying the current libTCC state and the buffer containing the code as
arguments. It is important to note that the code in the @code{GEfunc} buffer is
not executed at this stage. The purpose of this call is simply to compile the
code and make it available to the phenotype code which will be compiled next.

@findex tcc_compile_string()
Before the phenotype can be executed in the libTCC state, it must be wrapped
with the start and end code stored in the @code{SPstart} and @code{SPend}
buffers. The @code{char} buffer @code{buffer} is used to store the result of
concatenating the buffer @code{SPstart}, the phenotype code, and the buffer
@code{SPend}. An example of this concatenation is shown in
@ref{WrappedCPhenotype}. This buffer is then passed
to the libTCC state using the function @code{tcc_compile_string}. If the
compilation is successful, the libTCC state contains the executable form of the
wrapped phenotype, the supporting functions, and the variables required to
evaluate the GE phenotype.

@findex tcc_relocate()
@findex tcc_compile_string()
@findex tcc_get_symbol()
In order to execute the code in memory, the @code{main} function (declared in
the file @file{spiralstart.c}) must be explicitly invoked. This function is
accessed by first calling the function @code{tcc_relocate}. This makes all
function and variable symbols accessible through the C interface and should be
called after every call to @code{tcc_compile_string}. The function
@code{tcc_get_symbol} is then called with a pointer to the libTCC state, a
reference to a variable of type @code{unsigned long}, and the name of the
symbol we require ("main"). If the required symbol is found, the
@code{tcc_get_symbol} function stores its address in the @code{unsigned long}
variable. This variable is then cast into a function pointer of type @code{int
(*p_tccMainFunc)()}. The main function can the be invoked in the libTCC state
by calling the function through the pointer i.e. @code{p_tccMainFunc()}.

@findex tcc_get_symbol()
@findex tcc_delete()
One the main function has completed, the function @code{objfunc} must invoke
the function @code{AssignFitness} to retrieve the fitness value of the GE
individual. This is performed using the same method as the main function
invocation shown above. A function pointer which matches the signature of the
function @code{AssignFitness} must first be created. In this example, the
pointer is called @code{p_tccFitnessFunc"}. The libTCC function
@code{tcc_get_symbol} is then called to store the symbol location of this
function in the temporary variable @code{val}. This variable is then cast and
stored in the function pointer. The return value of the @code{AssignFitness}
function can then be retrieved by invoking the function through the pointer in
the normal fashion i.e. @code{fitness = p_tccFitnessFunc();}. The function then
deletes the libTCC state using the function @code{tcc_delete}.

A number of tests are done on the fitness variable to ensure that it is a
number. Finally, the fitness is assigned to the EO individual using the member
function @code{EOT::fitness}. The function then exits.


@c --- EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-lua.h ---
@node EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-lua.h, EXAMPLES/IntertwinedSpirals/GE_EO/Makefile, EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-libtcc.h, Intertwined Spirals Implementation with GE_EO
@subsubsection @file{eoGEEvalFunc-lua.h}

The file @file{eoGEEvalFunc-lua.h} declares the class @code{eoGEEvalFunc}
required by EO for individual evaluation. The intertwined spirals example uses
the C API of the Lua library to interpret, execute, and evaluate the GE
phenotype. Evaluation of the phenotype in this way results in significant
improvements in execution time over language compilers e.g. GCC, and TCC. The
following section describes the various files and functions that are part of
the Lua backend for the intertwined spirals example.

In order to access the Lua C API through the C++ code in the file
@file{eoGEEvalFunc-lua.h}, the @code{#include <header.h>} directives must be
enclosed in a special directive called @code{extern "C"} e.g.
@verbatim
extern "C"
{
#include <lua.h>
#include <lauxlib.h>
#include <lualib.h>
}
@end verbatim

This tells the compiler that the code in these files is C code and not C++
code. A global pointer to a @code{lua_State}, called @code{L} in this example,
is also created at the top of the file.for use by all the functions in the
file.

This class is a template class which allows the individual type @code{EOT} to
be specified when an instance of the class is created. The constructor is
responsible for initialising the GE mapper and setting up the libTCC evaluator
backend. The @code{mapper} object is initialised by specifying the maximum
number of mapping wraps and loading the BNF grammar file using the
@code{readBNFFile} member function. Each of these values are supplied as
parameters to the constructor function. If the process of loading the grammar
fails, an error message is printed to the standard error stream
(@code{std::cerr}) and the program exits.

@findex lua_open()
@findex luaL_openlibs()
The Lua state is opened in this function by a call to the lua API function
@code{lua_open}. Additional math and io libraries are added to this state using
the function @code{luaL_openlibs}. Once completed, the Lua state is then ready
to interpret and execute Lua code.

@findex luaL_dofile()
@findex lua_tostring()
In order to minimise the time required for individual evaluations in the
function @code{objfunc}, the Lua code in @file{GEspiral.lua} is loaded into the
state using the function @code{luaL_dofile}. This function loads and executes
the Lua code in this file which is discussed in more detail in
@ref{EXAMPLES/IntertwinedSpirals/GE_MITGALIB/GEspiral.lua}. It is important to
note that, because the file only contains variable declarations and function
implementations, no code is executed at this time. If an error occurs while
loading this file, Lua sets a error message at the top of its call stack. Each
element on the Lua stack has an index e.g. an index of @code{-1} represents the
element at the top of the stack. This index value is supplied to
the@code{lua_tostring} to retrieve the error message. The message is then
printed to standard error output and the program exits.

The member @code{operator()} provides the definition of the operator required
by EO for individual evaluation. It takes one argument of type @code{EOT} which
represents an EO individual. The function first checks that this individual has
not been evaluated previously by calling the member function
@code{EOT::invalid}. If the individual is invalid, then it needs to be
evaluated and assigned a fitness.  If the individual is valid, the function
exits.

In order to evaluate this individual, the mapper must be supplied with a valid
libGE structure. This is constructed by generating an array of integers and
copying each element from the EO individual. This array is then supplied to the
constructor of the @code{Genotype} object. This is then assigned to the
@code{mapper} object using the member function @code{setGenotype}. Once this is
complete, a libGE @code{Phenotype} is extracted from the @code{mapper} object.
If the phenotype is invalid, a fitness value of 0.0 is returned and the
function exits. If the phenotype is valid, the full executable code needs to be
constructed so that the phenotype can be evaluated in the Lua backend.

Instead of writing the phenotype code to a new file, the code is constructed in
memory by appending the required start code, phenotype code, and end code to a
@code{string} object (The start and end code are described in
@ref{EXAMPLES/IntertwinedSpirals/GE_MITGALIB/LuaStartCode} and
@ref{EXAMPLES/IntertwinedSpirals/GE_MITGALIB/LuaEndCode}).

@findex luaL_dostring()
This code is executed in the Lua runtime by calling the function
@code{luaL_dostring} and passing it a pointer to the Lua state and the buffer
containing the code to be executed. If execution fails, the error message is
retrieved from the Lua stack and printed to standard error output and the
program then exits.

@findex lua_getglobal()
@findex lua_isnumber()
@findex lua_tonumber()
If the compilation and execution is successful, the function
@code{lua_getglobal} is called to retrieve the Lua variable
@code{sumFitCaseTimes}. This function pushes the variable on to the top of the
stack. The value is checked and retrieved from the stack using the functions
@code{lua_isnumber} and @code{lua_tonumber}. The value is then assigned to the
@code{fitness} variable.

A number of tests are done on the fitness variable to ensure that it is a
number. Finally, the fitness is assigned to the EO individual using the member
function @code{EOT::fitness}. The function then exits.


@c --- EXAMPLES/IntertwinedSpirals/GE_EO/Makefile ---
@node EXAMPLES/IntertwinedSpirals/GE_EO/Makefile,  , EXAMPLES/IntertwinedSpirals/GE_EO/eoGEEvalFunc-lua.h, Intertwined Spirals Implementation with GE_EO
@subsubsection @file{Makefile}

The file @file{Makefile} contained in the example allows you to create a
program using a choice of evaluators for your phenotype strings. Use
@command{make} to create all executables, or @command{make GE*} to create a
specific evaluator implementation (where @command{*} is any of @command{GCC},
@command{SLANG}, @command{TCC}, @command{LIBTCC}, or @command{LUA}). At the top
of the file there are definitions for the location of the GALib, GE, and
evaluator specific header and library files. If you have installed any of these
in non-standard locations, make sure the values are adjusted to suit your
system.

The file @file{Makefile} uses the @command{-include} compiler flag to use only
the relevant include file for your choice of evaluator; if your compiler does
not accept that flag, you should replace it with the appropriate flag.

Finally, some of the evaluators require the pre-compilation of the file
@file{GEspiral.c}; this is done by the @file{Makefile}, when the relevant
target implementations are chosen.

@page
@c --- Intertwined Spirals Performance ---
@node Intertwined Spirals Performance,  , Intertwined Spirals Implementation with GE_EO,Intertwined Spirals Problem
@subsection Intertwined Spirals Performance

@menu
* GALib performance on Intertwined Spirals::  
* EO performance on Intertwined Spirals::  
@end menu

This section looks at the performance obtained with most of the search engines
tested, for this specific problem. All search engines used a similar
experimental setup: steady-state replacement, population size of 500
individuals, 100 generations, probability of crossover of 0.9, and probability
of bit-wise mutation of 0.01. Furthermore, each experiment was performed with
four different setups:

@itemize
@item Using a standard GE approach;
@item Using effective crossover;
@item Using sensible initialisation;
@item Using a combination of the last two.
@end itemize

The results show that the standard GE configuration fairs slightly worse than
the others and that the use of sensible initialisation alone produces slightly
better final individuals than others. The best individual evolved over 30 runs
achieved correct classification of approximately 141 individuals.

The average execution times of these runs for each of the five backends and for
both search engines are shown below.

@itemize
@item GCC: 66m41.456s(GALib) 62m54.525s (EO)
@item TCC: 12m56.476s (GALib) 12m13.464s (EO)
@item LIBTCC: 98m20.012s (GALib) 8m49.939s (EO)
@item SLANG: 1m25.292s (GALib) 1m8.705s (EO)
@item LUA: 0m46.493s (GALib) 0m38.655s (EO)
@end itemize

For reference, these results were obtained on a PC with a Pentium IV processor
running at 2.6GHz, 2048MB of memory, using Linux.

@page

@c --- GALib performance on Intertwined Spirals ---
@node GALib performance on Intertwined Spirals, EO performance on Intertwined Spirals, , Intertwined Spirals Performance
@subsubsection GALib performance

@image{spiral-mbipg-GALIB,12cm,,Mean Best Individual per Generation with GALib}

@c --- EO performance on Intertwined Spirals ---
@node EO performance on Intertwined Spirals,  , GALib performance on Intertwined Spirals, Intertwined Spirals Performance
@subsubsection EO performance

@image{spiral-mbipg-EO,12cm,,Mean Best Individual per Generation with EO}
